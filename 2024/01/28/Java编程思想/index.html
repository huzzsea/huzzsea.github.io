<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java编程思想 | huzzsea</title><meta name="author" content="huzzsea"><meta name="copyright" content="huzzsea"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章	对象导论1.1	抽象过程 抽象机制：所有编程语言都提供抽象机制，问题的复杂性取决于类型和质量 抽象语言的五大特征 万物皆为对象 程序是对象的集合，它们通过发送消息来告知彼此所要做的 每个对象都有自己的由其他对象所构成的存储 每个对象都拥有类型 某一特定类型的所有对象都可以接收同样的消息   对对象的描述：对象具有状态，行为和标识  1.2	每个对象都有一个接口 类描述了具有相同特性（数据元">
<meta property="og:type" content="article">
<meta property="og:title" content="Java编程思想">
<meta property="og:url" content="http://example.com/2024/01/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/index.html">
<meta property="og:site_name" content="huzzsea">
<meta property="og:description" content="第一章	对象导论1.1	抽象过程 抽象机制：所有编程语言都提供抽象机制，问题的复杂性取决于类型和质量 抽象语言的五大特征 万物皆为对象 程序是对象的集合，它们通过发送消息来告知彼此所要做的 每个对象都有自己的由其他对象所构成的存储 每个对象都拥有类型 某一特定类型的所有对象都可以接收同样的消息   对对象的描述：对象具有状态，行为和标识  1.2	每个对象都有一个接口 类描述了具有相同特性（数据元">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-01-28T14:55:47.000Z">
<meta property="article:modified_time" content="2024-01-28T15:31:12.752Z">
<meta property="article:author" content="huzzsea">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/01/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java编程思想',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-28 23:31:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="huzzsea"><span class="site-name">huzzsea</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java编程思想</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-28T14:55:47.000Z" title="发表于 2024-01-28 22:55:47">2024-01-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-28T15:31:12.752Z" title="更新于 2024-01-28 23:31:12">2024-01-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java编程思想"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第一章对象导论"><a href="#第一章对象导论" class="headerlink" title="第一章	对象导论"></a>第一章	对象导论</h2><h3 id="1-1抽象过程"><a href="#1-1抽象过程" class="headerlink" title="1.1	抽象过程"></a>1.1	抽象过程</h3><ul>
<li><strong>抽象机制</strong>：所有编程语言都提供抽象机制，问题的复杂性取决于类型和质量</li>
<li><strong>抽象语言的五大特征</strong><ul>
<li>万物皆为对象</li>
<li>程序是对象的集合，它们通过发送消息来告知彼此所要做的</li>
<li>每个对象都有自己的由其他对象所构成的存储</li>
<li>每个对象都拥有类型</li>
<li>某一特定类型的所有对象都可以接收同样的消息</li>
</ul>
</li>
<li><strong>对对象的描述</strong>：对象具有状态，行为和标识</li>
</ul>
<h3 id="1-2每个对象都有一个接口"><a href="#1-2每个对象都有一个接口" class="headerlink" title="1.2	每个对象都有一个接口"></a>1.2	每个对象都有一个接口</h3><ul>
<li>类描述了具有相同特性（数据元素）和行为（功能）的对象集合</li>
<li>类实际上就是一个数据类型，程序员通过定义类来适应问题，编程系统欣然接受新的类</li>
<li>接口确定了对某一特定对象所能发出的请求</li>
</ul>
<h3 id="1-3每个对象都提供服务"><a href="#1-3每个对象都提供服务" class="headerlink" title="1.3	每个对象都提供服务"></a>1.3	每个对象都提供服务</h3><ul>
<li>将对象想象为“服务提供者”，程序本身将向用户提供服务</li>
<li>服务提供者的思想有助于提高对象的内聚性，意味着一个软件构件的各个方面组合得很好</li>
</ul>
<h3 id="1-4被隐藏的具体实现"><a href="#1-4被隐藏的具体实现" class="headerlink" title="1.4	被隐藏的具体实现"></a>1.4	被隐藏的具体实现</h3><ul>
<li><p>程序开发人员可分为类创建者（创建新数据类型的程序员）和客户端程序员（使用数据类型的类消费者）</p>
</li>
<li><p>访问控制约束了客户端程序员，将实现隐藏起来</p>
</li>
<li><p>访问控制允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员</p>
</li>
</ul>
<h3 id="1-5复用具体体现"><a href="#1-5复用具体体现" class="headerlink" title="1.5	复用具体体现"></a>1.5	复用具体体现</h3><ul>
<li>组合：使用现有的类合成新的类，经常被视为<strong>“has-a”</strong>关系</li>
<li>新类的成员对象通常被声明为<strong>private</strong>，使得那些使用新类的客户端程序员不能访问它们，以及实现动态修改代码的行为</li>
</ul>
<h3 id="1-6继承"><a href="#1-6继承" class="headerlink" title="1.6	继承"></a>1.6	继承</h3><ul>
<li><strong>继承</strong>：以现有的基类为基础，复制并添加和修改这个副本，创建新的类</li>
<li>经过继承，两个类型可以有相同的特性和行为，但是其中一个类型可能比另一个拥有更多的特性，并且可以处理更多的消息</li>
<li>使基类和导出类<strong>产生差异</strong>的方式<ul>
<li>直接在导出类中添加新方法</li>
<li>覆盖，即改变现有基类的方法</li>
</ul>
</li>
<li><strong>“是一个”</strong>与<strong>“像是一个”</strong>关系<ul>
<li><code>is-a</code>：替代原则，不添加新方法，只覆盖基类的方法</li>
<li><code>is-like-a</code>：添加新的接口元素，拓展接口</li>
</ul>
</li>
</ul>
<h3 id="1-7伴随多态的可互换对象"><a href="#1-7伴随多态的可互换对象" class="headerlink" title="1.7	伴随多态的可互换对象"></a>1.7	伴随多态的可互换对象</h3><ul>
<li><strong>后期绑定</strong>：当向对象发送消息时，被调用的代码直到运行时才能确定</li>
<li><strong>向上转型</strong>：将导出类看做是它的基类</li>
</ul>
<h3 id="1-8单根继承结构"><a href="#1-8单根继承结构" class="headerlink" title="1.8	单根继承结构"></a>1.8	单根继承结构</h3><ul>
<li><strong>Object类</strong>：所有的类都继承自单一的基类</li>
<li>单根继承结构保证所有的对象都具备某些功能，使垃圾回收器的实现变得容易得多</li>
</ul>
<h3 id="1-9容器"><a href="#1-9容器" class="headerlink" title="1.9	容器"></a>1.9	容器</h3><ul>
<li><strong>容器</strong>：创建的一种数据类型，使得它持有对其他对象的引用</li>
<li>Java在其标准类库中包含大量的容器<ul>
<li>不同的容器提供了不同类型的接口和外部行为</li>
<li>不同的容器对于某些操作具有不同的效率</li>
</ul>
</li>
<li><strong>参数化类型（泛型）</strong>：编译器自动定制用于特定类型上的类，例如只接纳和取出特定类型的容器</li>
</ul>
<h3 id="1-10对象的创建和生命期"><a href="#1-10对象的创建和生命期" class="headerlink" title="1.10	对象的创建和生命期"></a>1.10	对象的创建和生命期</h3><ul>
<li><strong>动态内存分配方式</strong>：在堆的内存池中动态地创建对象，当需要一个新对象时，直接在堆中复制</li>
<li><strong>垃圾回收器</strong>：自动发现对象何时不再使用，并继而销毁它，避免暗藏的内存泄漏问题</li>
</ul>
<h3 id="1-11异常处理：处理错误"><a href="#1-11异常处理：处理错误" class="headerlink" title="1.11	异常处理：处理错误"></a>1.11	异常处理：处理错误</h3><ul>
<li><strong>异常处理</strong>：将异常从出错地点“抛出”，并被异常处理器”捕获“</li>
<li>异常处理是与程序正常执行路径并行的，在错误发生时执行的另一条路径，不会干扰正常的执行代码</li>
</ul>
<h3 id="1-12并发编程"><a href="#1-12并发编程" class="headerlink" title="1.12	并发编程"></a>1.12	并发编程</h3><ul>
<li><strong>并发编程</strong>：将问题切分成多个可独立运行的部分（线程），从而提高程序的响应能力</li>
<li><strong>并发编程的隐患</strong>：共享资源的使用，可以使用资源锁来解决</li>
</ul>
<h3 id="1-13Java与Internet"><a href="#1-13Java与Internet" class="headerlink" title="1.13	Java与Internet"></a>1.13	Java与Internet</h3><h4 id="Web是什么"><a href="#Web是什么" class="headerlink" title="Web是什么"></a>Web是什么</h4><ul>
<li><strong>客户&#x2F;服务器系统思想</strong>：系统具有一个中央信息存储池，用来存储某种数据，通常存在于数据库，可以根据需要将它分发给某些人员或机器集群</li>
<li>Web是一个巨型的客户&#x2F;服务器系统</li>
</ul>
<h4 id="客户端编程"><a href="#客户端编程" class="headerlink" title="客户端编程"></a>客户端编程</h4><ul>
<li><strong>客户端编程</strong>：Web浏览器利用空闲的时间执行工作，使得返回给用户的结果更加迅捷，使得网站更加具有交互性</li>
<li><strong>脚本语言</strong>：通过脚本语言，将客户端程序的源代码嵌入到<strong>HTML</strong>页面中，解释这种语言的插件自动被激活</li>
<li><strong>Java</strong>：通过<strong>applet</strong>在浏览器中运行以分发客户端软件，<strong>Java</strong>凭借Web浏览器内置的解释器，解决脚本语言难以解决的复杂问题</li>
</ul>
<h4 id="服务器端编程"><a href="#服务器端编程" class="headerlink" title="服务器端编程"></a>服务器端编程</h4><ul>
<li><strong>Java servlet</strong>：涉及到文件发送问题和数据库修改等，消除了处理具有不同能力的浏览器时遇到的问题</li>
</ul>
<h2 id="第二章一切都是对象"><a href="#第二章一切都是对象" class="headerlink" title="第二章	一切都是对象"></a>第二章	一切都是对象</h2><h3 id="2-1用引用操纵对象"><a href="#2-1用引用操纵对象" class="headerlink" title="2.1	用引用操纵对象"></a>2.1	用引用操纵对象</h3><ul>
<li><p>将一切都看做对象，操纵对象的标识符是对象的一个引用</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br><span class="line"><span class="comment">//此处只是创建引用，而不是对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2必须由你创建所有对象"><a href="#2-2必须由你创建所有对象" class="headerlink" title="2.2	必须由你创建所有对象"></a>2.2	必须由你创建所有对象</h3><h4 id="存储到什么地方"><a href="#存储到什么地方" class="headerlink" title="存储到什么地方"></a>存储到什么地方</h4><ul>
<li><strong>寄存器</strong>：最快的存储区，位于处理器内部</li>
<li><strong>堆栈</strong>：位于通用<strong>RAM</strong>（随机访问寄存器）中，可以通过操纵堆栈指针来管理内存</li>
<li><strong>堆</strong>：一种通用的内存池，也位于<strong>RAM</strong>，用于存放<strong>Java</strong>中的对象</li>
<li><strong>常量存储</strong>：通常直接存储在代码内部，在嵌入式系统中，可能会存放在<strong>ROM</strong>（只读存储器）中</li>
<li><strong>非RAM存储</strong>：<strong>流对象</strong>和<strong>持久化对象</strong>，可以完全存活于程序之外</li>
</ul>
<h4 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h4><ul>
<li><strong>基本类型</strong>：并非引用的“自动”变量，直接存储值，并置于堆栈中，更加地高效</li>
<li><strong>高精度数字</strong>：<strong>BigInteger</strong>支持任意精度的整数，<strong>BigDecimal</strong>支持任意精度的定点数</li>
</ul>
<h4 id="Java中的数组"><a href="#Java中的数组" class="headerlink" title="Java中的数组"></a>Java中的数组</h4><ul>
<li><strong>安全性</strong>：确保数组被初始化，进行范围检查</li>
</ul>
<h3 id="2-3永远不需要销毁对象"><a href="#2-3永远不需要销毁对象" class="headerlink" title="2.3	永远不需要销毁对象"></a>2.3	永远不需要销毁对象</h3><ul>
<li><p><strong>作用域</strong>：由花括号的位置决定</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">96</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在Java中不合法，不允许在c++中将较大作用域的变量隐藏的做法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对象的作用域</strong>：引用在作用域终点即消失，但<strong>new</strong>创建的对象可以存活于作用域外，直至被垃圾回收器清理</p>
</li>
</ul>
<h3 id="2-4创建新的数据类型，类"><a href="#2-4创建新的数据类型，类" class="headerlink" title="2.4	创建新的数据类型，类"></a>2.4	创建新的数据类型，类</h3><ul>
<li><p><strong>类的元素</strong>：字段（数据成员）和方法（成员函数）</p>
</li>
<li><p>基本成员默认值</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>boolean</strong></td>
<td align="center"><strong>false</strong></td>
</tr>
<tr>
<td align="center"><strong>char</strong></td>
<td align="center"><strong>‘\u0000’(null)</strong></td>
</tr>
<tr>
<td align="center"><strong>byte</strong></td>
<td align="center"><strong>(byte)0</strong></td>
</tr>
<tr>
<td align="center"><strong>short</strong></td>
<td align="center"><strong>(short)0</strong></td>
</tr>
<tr>
<td align="center"><strong>int</strong></td>
<td align="center"><strong>0</strong></td>
</tr>
<tr>
<td align="center"><strong>long</strong></td>
<td align="center"><strong>0L</strong></td>
</tr>
<tr>
<td align="center"><strong>float</strong></td>
<td align="center"><strong>0.0f</strong></td>
</tr>
<tr>
<td align="center"><strong>double</strong></td>
<td align="center"><strong>0.0d</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2-5方法，参数与返回值"><a href="#2-5方法，参数与返回值" class="headerlink" title="2.5	方法，参数与返回值"></a>2.5	方法，参数与返回值</h3><ul>
<li><p><strong>方法的基本组成部分</strong>：名称，参数，返回值和方法体</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReturnType <span class="title function_">methodName</span><span class="params">(<span class="comment">/* Argument list */</span>)</span>&#123;</span><br><span class="line">	<span class="comment">/* Method body */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参数列表</strong>：指定传递给方法的信息，采用对象引用的形式</p>
</li>
</ul>
<h3 id="2-6构建一个Java程序"><a href="#2-6构建一个Java程序" class="headerlink" title="2.6	构建一个Java程序"></a>2.6	构建一个Java程序</h3><ul>
<li><strong>名字可见性</strong>：使用反转域名来命名类库，避免名称的重复</li>
<li><strong>运用其他构件</strong>：使用<strong>import</strong>语句指示编译器导入一个包</li>
<li><strong>static关键字</strong>：使域或方法不与任何对象实例关联到一起，在未创建对象时，也可以访问其对象或访问其域</li>
</ul>
<h3 id="2-7你的第一个Java程序"><a href="#2-7你的第一个Java程序" class="headerlink" title="2.7	你的第一个Java程序"></a>2.7	你的第一个Java程序</h3><ul>
<li><strong>args</strong>：存储命令行参数</li>
</ul>
<h3 id="2-8注释与嵌入文档"><a href="#2-8注释与嵌入文档" class="headerlink" title="2.8	注释与嵌入文档"></a>2.8	注释与嵌入文档</h3><ul>
<li><p><strong>注释风格</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">//this is a Java program</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多行注释</span></span><br><span class="line"><span class="comment">/* this is</span></span><br><span class="line"><span class="comment">* a Java program</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注释文档</strong>：使用<strong>javadoc</strong>提取注释，输出一个HTML文件</p>
</li>
<li><p><strong>一些标签示例</strong></p>
<ul>
<li><code>@see</code>：引用其他类的文档，生成一个超链接</li>
<li><code>&#123;@link package.class#emmber label&#125;</code>：引用其他类</li>
<li><code>&#123;@docRoot&#125;</code>：产生到根目录的相对路径，用于文档树页面的显式超链接</li>
<li><code>&#123;@inheritRoot&#125;</code>：从基类中继承相关文档到该注释中</li>
<li><code>@version (version-information)</code>：<strong>javadoc</strong>命令行使用**-version**命令，提取出版本信息</li>
<li><code>@author (author-information)</code>：<strong>javadoc</strong>命令行使用**-author**命令，提取出作者信息</li>
<li><code>@since</code>：指定程序代码最早使用的版本</li>
<li><code>@param (para-name description)</code>：生成参数列表</li>
<li><code>@return (description)</code>：生成返回值信息</li>
<li><code>@throws (fully-qualified-class-name description)</code>：生成抛出异常信息</li>
<li><code>@deprecated</code>：弃用文本，指名一个过期的类或成员，表明该类或方法不建议使用</li>
</ul>
</li>
</ul>
<h3 id="2-9编程风格"><a href="#2-9编程风格" class="headerlink" title="2.9	编程风格"></a>2.9	编程风格</h3><ul>
<li><strong>编程风格</strong><ul>
<li>类的首字母要大写</li>
<li><strong>驼峰风格</strong>：将单词拼接在一起，内部的每一个单词首字母大写</li>
</ul>
</li>
</ul>
<h2 id="第三章操作符"><a href="#第三章操作符" class="headerlink" title="第三章	操作符"></a>第三章	操作符</h2><h3 id="3-1更简单的打印语句"><a href="#3-1更简单的打印语句" class="headerlink" title="3.1	更简单的打印语句"></a>3.1	更简单的打印语句</h3><ul>
<li>静态导入类库，简化打印语句</li>
</ul>
<h3 id="3-2使用Java操作符"><a href="#3-2使用Java操作符" class="headerlink" title="3.2	使用Java操作符"></a>3.2	使用Java操作符</h3><ul>
<li><strong>操作符</strong>：接受一个或多个参数，并生成一个新值，除<strong>String</strong>外只能操作基本类型</li>
</ul>
<h3 id="3-3优先级"><a href="#3-3优先级" class="headerlink" title="3.3	优先级"></a>3.3	优先级</h3><ul>
<li><strong>优先级</strong>：计算顺序，使用括号明确</li>
</ul>
<h3 id="3-4赋值"><a href="#3-4赋值" class="headerlink" title="3.4	赋值"></a>3.4	赋值</h3><ul>
<li><p><strong>别名现象</strong>：当使用对象进行赋值时，真正操作的是对象的引用，若改变其中任何一个对象，会导致其余对象也发生变化</p>
</li>
<li><p><strong>方法中的别名问题</strong>：方法不会复制参数的副本，实际上只是传递一个引用</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        B b=<span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">1</span>);</span><br><span class="line">        B.f(b);</span><br><span class="line">        System.out.println(b.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(B b2)</span>&#123;</span><br><span class="line">        b2.value=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-5算术操作符"><a href="#3-5算术操作符" class="headerlink" title="3.5	算术操作符"></a>3.5	算术操作符</h3><ul>
<li><strong>Random类</strong>：将当前时间作为随机数生成器的种子，生成随机数</li>
</ul>
<h3 id="3-6自动递增和递减"><a href="#3-6自动递增和递减" class="headerlink" title="3.6	自动递增和递减"></a>3.6	自动递增和递减</h3><ul>
<li><strong>前缀式</strong>：操作符位于变量或表达式的前面，先执行运算后生成值</li>
<li><strong>后缀式</strong>：操作符位于变量或表达式的后面，先生成值后执行运算</li>
</ul>
<h3 id="3-7关系操作符"><a href="#3-7关系操作符" class="headerlink" title="3.7	关系操作符"></a>3.7	关系操作符</h3><ul>
<li><strong>&#x3D;&#x3D; 和 equals</strong>：**&#x3D;&#x3D;<strong>比较的是两个操作数的引用，可以根据需要重写</strong>equals**方法来判断两个对象是否相等</li>
</ul>
<h3 id="3-8逻辑操作符"><a href="#3-8逻辑操作符" class="headerlink" title="3.8	逻辑操作符"></a>3.8	逻辑操作符</h3><ul>
<li>不可以将非布尔值当做布尔值用在逻辑表达式中</li>
<li>在应该使用<strong>String</strong>值的地方使用了布尔值，会自动转换成文本文档</li>
<li><strong>短路</strong>：一旦能够明确无误地确定整个表达式的值，就不会计算表达式余下部分</li>
</ul>
<h3 id="3-9直接常量"><a href="#3-9直接常量" class="headerlink" title="3.9	直接常量"></a>3.9	直接常量</h3><ul>
<li><strong>long</strong>等数据类型标明后缀类型，以避免编译器混淆类型</li>
<li><strong>进制转换</strong><ul>
<li>10进制转2进制：<code>Integer.toBinaryString(n);</code></li>
<li>10进制转8进制： <code>Integer.toOctalString(n);</code></li>
<li>10进制转16进制：<code>Integer.toHexString(n);</code></li>
<li>10进制转r进制：<code>Integer.toString(100, r);</code></li>
<li>r进制转10进制： <code>Integer.parseInt((String) s,(int) r);</code></li>
</ul>
</li>
<li><strong>指数计数法</strong>：<code>a.be^x=a.b*10^x</code></li>
</ul>
<h3 id="3-10按位操作符"><a href="#3-10按位操作符" class="headerlink" title="3.10	按位操作符"></a>3.10	按位操作符</h3><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>&amp;</strong></td>
<td align="center"><strong>按位与</strong></td>
</tr>
<tr>
<td align="center"><strong>|</strong></td>
<td align="center"><strong>按位或</strong></td>
</tr>
<tr>
<td align="center"><strong>^</strong></td>
<td align="center"><strong>按位异或</strong></td>
</tr>
<tr>
<td align="center"><strong>~</strong></td>
<td align="center"><strong>按位非</strong></td>
</tr>
</tbody></table>
<h3 id="3-11移位操作符"><a href="#3-11移位操作符" class="headerlink" title="3.11	移位操作符"></a>3.11	移位操作符</h3><ul>
<li><strong>左移位操作符</strong><code>&lt;&lt;</code>：按照操作符右侧指定位数将操作符左边的操作数向左移动（低位补0）</li>
<li><strong>有符号右移位操作符</strong><code>&gt;&gt;</code>：按照操作符右侧指定位数将操作符左边的操作数向右移动，正数高位补0，负数高位补1</li>
<li><strong>无符号右移位操作符</strong><code>&gt;&gt;&gt;</code>：同有符号右移，高位始终补0</li>
</ul>
<h3 id="3-12三元操作符if-else"><a href="#3-12三元操作符if-else" class="headerlink" title="3.12	三元操作符if-else"></a>3.12	三元操作符if-else</h3><ul>
<li><strong>条件操作符</strong><code>boolean-exp ? value0 : value1</code>：如果布尔值为<strong>true</strong>，表达式值为<strong>value0</strong>，否则为<strong>value1</strong></li>
</ul>
<h3 id="3-13字符串操作符-和"><a href="#3-13字符串操作符-和" class="headerlink" title="3.13	字符串操作符+和+&#x3D;"></a>3.13	字符串操作符+和+&#x3D;</h3><ul>
<li>**+<strong>和</strong>+&#x3D;**用于字符串时，会将所有操作数转换成字符串类型</li>
</ul>
<h3 id="3-14使用操作符时常犯的错误"><a href="#3-14使用操作符时常犯的错误" class="headerlink" title="3.14	使用操作符时常犯的错误"></a>3.14	使用操作符时常犯的错误</h3><ul>
<li>Java编译器避免将一种类型当成另一种类型使用</li>
</ul>
<h3 id="3-15类型转换操作符"><a href="#3-15类型转换操作符" class="headerlink" title="3.15	类型转换操作符"></a>3.15	类型转换操作符</h3><ul>
<li><strong>窄化转换</strong>：将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型，有可能面临信息丢失的危险</li>
<li><strong>扩展转换</strong>：与窄化转换相反，不必显式进行转换，不会造成任何信息的丢失</li>
<li><strong>截尾和舍入</strong>：窄化转换时会对数字执行截尾操作，可以使用**Math.round()**方法获得舍入结果</li>
<li><strong>提升</strong>：表达式结果的类型取决于表达式中最大的数据类型</li>
</ul>
<h3 id="3-16Java没有sizeof"><a href="#3-16Java没有sizeof" class="headerlink" title="3.16	Java没有sizeof"></a>3.16	Java没有sizeof</h3><ul>
<li><strong>Java</strong>运行在虚拟机上，所有的数据类型大小都相等，不会产生移植问题</li>
</ul>
<h2 id="第四章控制执行流程"><a href="#第四章控制执行流程" class="headerlink" title="第四章	控制执行流程"></a>第四章	控制执行流程</h2><h3 id="4-1true和false"><a href="#4-1true和false" class="headerlink" title="4.1	true和false"></a>4.1	true和false</h3><ul>
<li>条件语句利用条件表达式的值决定执行路径，不允许使用非布尔值</li>
</ul>
<h3 id="4-2if-else"><a href="#4-2if-else" class="headerlink" title="4.2	if-else"></a>4.2	if-else</h3><ul>
<li><p><strong>if-else语句</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Boolean-expression)</span><br><span class="line">    statement</span><br><span class="line">或</span><br><span class="line">    <span class="keyword">if</span>(Boolean-expression)</span><br><span class="line">	    statement</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        statement</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-3迭代"><a href="#4-3迭代" class="headerlink" title="4.3	迭代"></a>4.3	迭代</h3><ul>
<li><p><strong>do-while语句</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="title function_">while</span><span class="params">(Boolean-expression)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>for语句</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialization;Boolean-expression;step)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>逗号操作符</strong>：用于<strong>for</strong>语句的初始化和步进控制部分，被分割的语句均会独立执行</p>
</li>
</ul>
<h3 id="4-4Foreach语法"><a href="#4-4Foreach语法" class="headerlink" title="4.4	Foreach语法"></a>4.4	Foreach语法</h3><ul>
<li><p><strong>foreach用于数组和容器</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-5return"><a href="#4-5return" class="headerlink" title="4.5	return"></a>4.5	return</h3><ul>
<li><strong>return关键字</strong><ul>
<li>指定一个方法返回什么值</li>
<li>导致当前方法退出，并返回值</li>
</ul>
</li>
</ul>
<h3 id="4-6break和continue"><a href="#4-6break和continue" class="headerlink" title="4.6	break和continue"></a>4.6	break和continue</h3><ul>
<li><strong>break关键字</strong>：强制退出循环，不执行循环中剩余语句</li>
<li><strong>continue关键字</strong>：停止执行当前的迭代，退出循环起始处，开始下一次迭代</li>
</ul>
<h3 id="4-7臭名昭著的goto"><a href="#4-7臭名昭著的goto" class="headerlink" title="4.7	臭名昭著的goto"></a>4.7	臭名昭著的goto</h3><ul>
<li><p><strong>goto语句</strong>：源码级的跳转导致程序的控制流程的混乱</p>
</li>
<li><p><strong>标签</strong>：用于迭代语句之前，<strong>break</strong>和<strong>continue</strong>会中断循环，直到标签所在的地方</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">label1:</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span> label1;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">label2:</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span> label2;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-8switch"><a href="#4-8switch" class="headerlink" title="4.8	switch"></a>4.8	switch</h3><ul>
<li><p><strong>switch选择语句</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integral-selector)&#123;</span><br><span class="line">    <span class="keyword">case</span> integral-value1 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value1 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value1 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> integral-value1 : statement; <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">default</span> : statement; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第五章初始化与清理"><a href="#第五章初始化与清理" class="headerlink" title="第五章	初始化与清理"></a>第五章	初始化与清理</h2><h3 id="5-1用构造器确保初始化"><a href="#5-1用构造器确保初始化" class="headerlink" title="5.1	用构造器确保初始化"></a>5.1	用构造器确保初始化</h3><ul>
<li><p><strong>构造器</strong>：名称与类名相同，不返回任何值</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rock</span>&#123;</span><br><span class="line">	Rock()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Rock&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-2方法重载"><a href="#5-2方法重载" class="headerlink" title="5.2	方法重载"></a>5.2	方法重载</h3><ul>
<li><strong>区别重载的方法</strong>：通过参数列表的不同区别重载方法，包括参数列表的顺序</li>
<li><strong>涉及基本类型的重载</strong>：如果传入的实际参数大于形式参数，会提升参数数据类型，反之编译器会报错</li>
<li><strong>以返回值区分重载方法</strong>：返回值重载会产生歧义，导致编译器报错</li>
</ul>
<h3 id="5-3默认构造器"><a href="#5-3默认构造器" class="headerlink" title="5.3	默认构造器"></a>5.3	默认构造器</h3><ul>
<li><strong>默认构造器</strong>：当且仅当在未创建任何构造器的情况下，编译器会自动生成一个无参构造器</li>
</ul>
<h3 id="5-4this关键字"><a href="#5-4this关键字" class="headerlink" title="5.4	this关键字"></a>5.4	this关键字</h3><ul>
<li><strong>在构造器中调用构造器</strong>：使用<strong>this</strong>关键字，只能使用一个<strong>this</strong>语句，并且只能用于构造器开头</li>
</ul>
<h3 id="5-5清理：终结处理和垃圾回收"><a href="#5-5清理：终结处理和垃圾回收" class="headerlink" title="5.5	清理：终结处理和垃圾回收"></a>5.5	清理：终结处理和垃圾回收</h3><ul>
<li>**finalize()**：在垃圾回收器准备释放对象占用空间前被调用，在下一次回收动作发生时，才会真正地回收内存空间，常常用于确保某些非内存资源的释放</li>
</ul>
<h3 id="5-6成员初始化"><a href="#5-6成员初始化" class="headerlink" title="5.6	成员初始化"></a>5.6	成员初始化</h3><ul>
<li><strong>Java</strong>要求方法的局部变量必须初始化，否则产生编译时错误，但如果是基本数据类型，则会赋予初始值</li>
</ul>
<h3 id="5-7构造器初始化"><a href="#5-7构造器初始化" class="headerlink" title="5.7	构造器初始化"></a>5.7	构造器初始化</h3><ul>
<li><strong>初始化顺序</strong>：按照变量定义时的顺序决定变量初始化的顺序</li>
<li><strong>静态对象的初始化</strong>：只有在第一个对象被创建或者第一次访问时，才会初始化静态对象，并且此后不会再次被初始化，静态对象的初始化优先于非静态对象</li>
</ul>
<h3 id="5-8数组初始化"><a href="#5-8数组初始化" class="headerlink" title="5.8	数组初始化"></a>5.8	数组初始化</h3><ul>
<li><p><strong>数组的两种初始化方式</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a=<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Integer[] b=&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可变参数列表</strong>：一种特殊的形参类型，能够让方法接受不定数量的参数，且必须是方法定义中的最后一个参数</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String ... strings)</span>&#123;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(String string : strings)&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;the Num.&quot;</span>+index+++<span class="string">&quot; string: &quot;</span>+string);</span><br><span class="line">        System.out.print(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    print(<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    print(<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-9枚举类型"><a href="#5-9枚举类型" class="headerlink" title="5.9	枚举类型"></a>5.9	枚举类型</h3><ul>
<li><strong>枚举</strong>：一种特殊的数据类型，它定义了一个有限的值集合，使程序更具可读性和易用性</li>
</ul>
<h2 id="第六章访问权限控制"><a href="#第六章访问权限控制" class="headerlink" title="第六章	访问权限控制"></a>第六章	访问权限控制</h2><h3 id="6-1包：库单元"><a href="#6-1包：库单元" class="headerlink" title="6.1	包：库单元"></a>6.1	包：库单元</h3><ul>
<li><p><strong>编译单元</strong>：一个后缀名为**.java<strong>的源代码文件，一个编译单元只能拥有一个公开的</strong>public class**，且类名与文件名相同</p>
</li>
<li><p><strong>package关键字</strong>：<strong>package</strong>是用来组织和管理类的一种机制，一个<strong>package</strong>可以包含多个类和子包，它们可以帮助开发人员更加有效地组织和管理自己的代码，文件中除注释外必须是<strong>package语句</strong></p>
</li>
<li><p><strong>包的命名规则</strong></p>
<ul>
<li><p>包名全部为小写字母</p>
</li>
<li><p>包名使用点分隔符（.）将各个单词连接在一起</p>
</li>
<li><p>包名应该基于域名的倒置命名法来命名</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置环境变量CLASSPATH以包含多个可供查询的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="comment">//路径C:\DOC\JavaT\net\mindview\simple</span></span><br><span class="line"><span class="comment">//CLASSPATH=.;D:\JAVA\LIB;C:\DOC\JavaT</span></span><br><span class="line"><span class="keyword">import</span> net.mindview.simple.*;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当发生类名冲突时，编译器会报错以要求指明类的全名</p>
</li>
</ul>
<h3 id="6-2Java访问权限修饰词"><a href="#6-2Java访问权限修饰词" class="headerlink" title="6.2	Java访问权限修饰词"></a>6.2	Java访问权限修饰词</h3><ul>
<li><p><strong>访问权限修饰词</strong></p>
<table>
<thead>
<tr>
<th align="center">修饰词</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>public</strong></td>
<td align="center">最大权限，修饰的成员可以被任何类访问，在同一个包下的类和不同包下的类都可以访问</td>
</tr>
<tr>
<td align="center"><strong>protected</strong></td>
<td align="center">能够被同一个包下的类以及不同包下的子类访问，但是不能被不同包下的非子类访问</td>
</tr>
<tr>
<td align="center"><strong>默认</strong></td>
<td align="center">当没有任何访问修饰符时，即为默认访问权限，只能被同一个包下的类访问，无法被其他包下的类访问</td>
</tr>
<tr>
<td align="center"><strong>private</strong></td>
<td align="center">最小权限，只能被定义该成员的类访问，不能被同一包下的其他类或者不同包下的类访问</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="6-3接口和实现"><a href="#6-3接口和实现" class="headerlink" title="6.3	接口和实现"></a>6.3	接口和实现</h3><ul>
<li>访问权限的控制常被称为具体实现的隐藏，用于设定客户端程序员可以使用和不可以使用的界限，和接口与实现的分离</li>
</ul>
<h3 id="6-4类的访问权限"><a href="#6-4类的访问权限" class="headerlink" title="6.4	类的访问权限"></a>6.4	类的访问权限</h3><ul>
<li><strong>修饰词限制</strong><ul>
<li>每个编译单元只能拥有一个<strong>public</strong>类，且类名与文件名相同</li>
<li>如果不含有<strong>public</strong>类，可随意对文件命名</li>
</ul>
</li>
<li>类不可以使用<strong>private</strong>修饰，只能使用<strong>package-private</strong>或<strong>public</strong>，如果不希望任何其它类拥有访问权限，可以将构造器指定为<strong>private</strong></li>
</ul>
<h2 id="第七章复用类"><a href="#第七章复用类" class="headerlink" title="第七章	复用类"></a>第七章	复用类</h2><h3 id="7-1组合语法"><a href="#7-1组合语法" class="headerlink" title="7.1	组合语法"></a>7.1	组合语法</h3><ul>
<li><strong>组合技术</strong>：将所需要的对象引用置于新类之中</li>
</ul>
<h3 id="7-2继承语法"><a href="#7-2继承语法" class="headerlink" title="7.2	继承语法"></a>7.2	继承语法</h3><ul>
<li><strong>extends语句</strong>：导出类继承基类，并自动得到基类中所有的域和方法</li>
<li><strong>初始化基类</strong>：在生成导出类对象时，总会调用基类构造器，且基类构造器先于导出类构造器被调用</li>
<li><strong>super关键字</strong>：带参数构造器必须显式地使用<strong>super</strong>语句调用基类的构造器，且必须写在构造器的第一行</li>
</ul>
<h3 id="7-3代理"><a href="#7-3代理" class="headerlink" title="7.3	代理"></a>7.3	代理</h3><ul>
<li><p><strong>代理</strong>：一个类代表另一个类的功能，并控制对该类的访问，从而实现为其他对象提供一种代理控制对目标对象的访问的功能</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标对象：实现目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RealImage</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line">        loadFromDisk(fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Displaying &quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadFromDisk</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Loading &quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象：实现与目标对象相同的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realImage == <span class="literal">null</span>) &#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> <span class="title class_">RealImage</span>(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        realImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-4结合实用组合和继承"><a href="#7-4结合实用组合和继承" class="headerlink" title="7.4	结合实用组合和继承"></a>7.4	结合实用组合和继承</h3><ul>
<li><strong>名称屏蔽</strong>：在导出类中重新定义方法，不会屏蔽其在基类中的任何版本</li>
</ul>
<h3 id="7-5在组合与继承之间选择"><a href="#7-5在组合与继承之间选择" class="headerlink" title="7.5	在组合与继承之间选择"></a>7.5	在组合与继承之间选择</h3><ul>
<li><strong>is-a</strong>（是一个）用继承表达关系，<strong>has-a</strong>（有一个）用组合表达关系</li>
</ul>
<h3 id="7-6protected关键字"><a href="#7-6protected关键字" class="headerlink" title="7.6	protected关键字"></a>7.6	protected关键字</h3><ul>
<li><strong>protect关键字</strong>：对于类用户而言<strong>private</strong>，对于任何继承自此类的导出类或其他任何位于同一个包内的内而言，是可以访问的</li>
</ul>
<h3 id="7-7向上转型"><a href="#7-7向上转型" class="headerlink" title="7.7	向上转型"></a>7.7	向上转型</h3><ul>
<li><strong>向上转型</strong>：将一个子类对象转换成其父类对象的过程，由于面向对象编程的特性，每个子类对象都可以被当作父类对象使用，可以将一个子类对象赋值给一个父类引用变量，以实现向上转型</li>
</ul>
<h3 id="7-8final关键字"><a href="#7-8final关键字" class="headerlink" title="7.8	final关键字"></a>7.8	final关键字</h3><ul>
<li><strong>final数据</strong><ul>
<li>修饰基本类型时，数值恒定不变；修饰引用类型时，引用恒定不变</li>
<li><strong>空白final</strong>：被声明为<strong>final</strong>但又未给初值的域，在使用前必须在构造器中进行初始化</li>
<li><strong>final参数</strong>：在参数列表中以声明的方式将参数指明为<strong>final</strong>，表示无法在方法中更改参数引用所指向的对象</li>
</ul>
</li>
<li><strong>final方法</strong><ul>
<li>将方法锁定，以防任何继承类修改它的含义</li>
<li>类中所有的<strong>private</strong>方法都隐式地指定为是<strong>final</strong>的</li>
</ul>
</li>
<li><strong>final</strong>类：不允许继承该类</li>
</ul>
<h3 id="7-9初始化及类的加载"><a href="#7-9初始化及类的加载" class="headerlink" title="7.9	初始化及类的加载"></a>7.9	初始化及类的加载</h3><ul>
<li><strong>类的加载顺序</strong><ul>
<li>优先加载加载类的基类，无论是否需要产生基类的对象</li>
<li>按照继承关系依次执行<strong>static</strong>的初始化</li>
<li>创建对象后，对象中所有基本类型被设为默认值，然后执行对象的构造器</li>
</ul>
</li>
</ul>
<h2 id="第八章多态"><a href="#第八章多态" class="headerlink" title="第八章	多态"></a>第八章	多态</h2><h3 id="8-1再论向上转型"><a href="#8-1再论向上转型" class="headerlink" title="8.1	再论向上转型"></a>8.1	再论向上转型</h3><ul>
<li>向上转型避免了继承后，需要更多重载的编程过程，如果仅接收基类作为参数，可以简化代码的结构</li>
</ul>
<h3 id="8-2转机"><a href="#8-2转机" class="headerlink" title="8.2	转机"></a>8.2	转机</h3><ul>
<li><strong>绑定</strong>：讲一个方法调用同一个方法主体关联起来<ul>
<li><strong>前期绑定</strong>：在程序执行前绑定</li>
<li><strong>后期绑定</strong>：在运行时根据对象的类型进行绑定</li>
</ul>
</li>
<li><strong>注意事项</strong><ul>
<li>私有方法的覆盖不会产生多态现象</li>
<li>域和静态方法不具备多态性</li>
</ul>
</li>
</ul>
<h3 id="8-3构造器和多态"><a href="#8-3构造器和多态" class="headerlink" title="8.3	构造器和多态"></a>8.3	构造器和多态</h3><ul>
<li><strong>构造器的调用顺序</strong><ul>
<li>调用基类构造器</li>
<li>按声明顺序调用成员的初始化方法</li>
<li>调用导出类构造器的主体</li>
</ul>
</li>
<li><strong>构造器内部的多态方法的行为</strong><ul>
<li>在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零</li>
<li>如前所述那样调用基类构造器</li>
<li>按照声明的顺序调用成员的初始化方法</li>
<li>调用导出类的构造器主体</li>
</ul>
</li>
</ul>
<h3 id="8-4协变返回类型"><a href="#8-4协变返回类型" class="headerlink" title="8.4	协变返回类型"></a>8.4	协变返回类型</h3><ul>
<li><strong>协变返回类型</strong>：在导出类中的被覆盖方法可以返回基类方法的返回基类的某种导出类型</li>
</ul>
<h3 id="8-5用继承进行设计"><a href="#8-5用继承进行设计" class="headerlink" title="8.5	用继承进行设计"></a>8.5	用继承进行设计</h3><ul>
<li><strong>纯继承与拓展</strong>：采用<strong>纯粹</strong>的方式来创建继承层次结构，只有在基类中已经建立的方法才可以在导出类中被覆盖，基类与导出类拥有完全相同的接口</li>
<li><strong>向下转型与运行时类型识别</strong>：向下转型时会进行<strong>运行时类型识别</strong>，如果不是希望的类型会报错</li>
</ul>
<h2 id="第九章接口"><a href="#第九章接口" class="headerlink" title="第九章	接口"></a>第九章	接口</h2><h3 id="9-1抽象类和抽象方法"><a href="#9-1抽象类和抽象方法" class="headerlink" title="9.1	抽象类和抽象方法"></a>9.1	抽象类和抽象方法</h3><ul>
<li><strong>抽象方法</strong>：只有方法声明，没有具体实现的方法，只能在抽象类或者接口中存在，不能被直接调用，需要由子类进行实现</li>
<li><strong>抽象类</strong>：在类的声明中包含抽象方法的类，不能被实例化，必须被子类继承并实现其中的抽象方法才能被使用</li>
<li><strong>使用场合</strong><ul>
<li><strong>定义通用接口</strong>：通过定义抽象方法和抽象类，使得多个具体的子类可以共享这些接口和基础实现逻辑，提高了代码的复用性和效率</li>
<li><strong>约束子类行为</strong>：抽象类可以定义一些基础的方法和属性，但是对于某些具体的属性和方法，需要等到子类中具体实现之后才可以使用，从而达到约束子类行为的目的</li>
<li><strong>提高代码可读性和可维护性</strong>：通过抽象类将某些具体的实现逻辑封装起来，有助于提高代码的可读性和可维护性</li>
</ul>
</li>
</ul>
<h3 id="9-2接口"><a href="#9-2接口" class="headerlink" title="9.2	接口"></a>9.2	接口</h3><ul>
<li><strong>interface关键字</strong>：产生完全抽象的类，只提供形式，不提供任何具体实现</li>
<li><strong>接口方法</strong>：默认为<strong>public</strong>且必须被定义为<strong>public</strong>，否则在方法继承过程中会导致其访问权限降低（在高版本Java中，接口中的普通方法也是被允许的，此类方法为静态方法，可以使用<strong>private</strong>来实现工具函数）</li>
</ul>
<h3 id="9-3完全解耦"><a href="#9-3完全解耦" class="headerlink" title="9.3	完全解耦"></a>9.3	完全解耦</h3><ul>
<li><strong>策略设计模式</strong>：根据所传递参数对象不同，而具有不同行为的方法</li>
<li><strong>解耦</strong>：将接口从具体实现中解耦，使得接口可以用于多种不同的具体实现，代码更具可复用性</li>
</ul>
<h3 id="9-4Java中的多重继承"><a href="#9-4Java中的多重继承" class="headerlink" title="9.4	Java中的多重继承"></a>9.4	Java中的多重继承</h3><ul>
<li><strong>多重继承</strong>：继承任意多个接口来实现多重继承，接口没有任何具体实现，不会产生类继承所面临的问题</li>
</ul>
<h3 id="9-5通过继承来拓展接口"><a href="#9-5通过继承来拓展接口" class="headerlink" title="9.5	通过继承来拓展接口"></a>9.5	通过继承来拓展接口</h3><ul>
<li><strong>拓展接口</strong>：通过继承多个接口，或者在接口中添加新的声明，来实现接口的拓展</li>
<li><strong>多重继承的名字冲突</strong>：返回类型或方法签名不同的相同方法，不允许被同时继承</li>
</ul>
<h3 id="9-6适配接口"><a href="#9-6适配接口" class="headerlink" title="9.6	适配接口"></a>9.6	适配接口</h3><ul>
<li><strong>适配接口</strong>：使用<strong>策略设计模式</strong>和<strong>适配器模式</strong>，来实现任何类对方法进行适配</li>
</ul>
<h3 id="9-7接口中的域"><a href="#9-7接口中的域" class="headerlink" title="9.7	接口中的域"></a>9.7	接口中的域</h3><ul>
<li>接口中的任何域都是<strong>static</strong>和<strong>final</strong>的，可以用来实现与<strong>enum</strong>类似的功能</li>
<li>接口中的域不允许空<strong>final</strong>，必须进行初始化</li>
</ul>
<h3 id="9-8嵌套接口"><a href="#9-8嵌套接口" class="headerlink" title="9.8	嵌套接口"></a>9.8	嵌套接口</h3><ul>
<li>接口可以嵌套在其他接口或类当中</li>
</ul>
<h3 id="9-9接口与工厂"><a href="#9-9接口与工厂" class="headerlink" title="9.9	接口与工厂"></a>9.9	接口与工厂</h3><ul>
<li><strong>工厂方法设计模式</strong>：在工厂对象上调用创建方法，生成接口的某个实现对象</li>
</ul>
<h2 id="第十章内部类"><a href="#第十章内部类" class="headerlink" title="第十章	内部类"></a>第十章	内部类</h2><h3 id="10-1创建内部类"><a href="#10-1创建内部类" class="headerlink" title="10.1	创建内部类"></a>10.1	创建内部类</h3><ul>
<li><strong>内部类</strong>：将一个类的定义放在另一个类的定义内部，使用时需要指明其类型<strong>OuterClassName.InnerClassName</strong></li>
</ul>
<h3 id="10-2链接到外部类"><a href="#10-2链接到外部类" class="headerlink" title="10.2	链接到外部类"></a>10.2	链接到外部类</h3><ul>
<li>内部类能够访问其外围对象的所有成员，拥有其外围类所有元素的访问权</li>
</ul>
<h3 id="10-3使用-this与-new"><a href="#10-3使用-this与-new" class="headerlink" title="10.3	使用.this与.new"></a>10.3	使用.this与.new</h3><ul>
<li><p><strong>.this关键字</strong>：生成对外部类对象的引用</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotThis</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> DotThis <span class="title function_">outer</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DotThis.<span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">inner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DotThis dt=<span class="keyword">new</span> <span class="title class_">DotThis</span>();</span><br><span class="line">        DotThis.Inner dti= dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>.new关键字</strong>：提供对其他外部类对象的引用</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        DotNew dn=<span class="keyword">new</span> <span class="title class_">DotNew</span>();</span><br><span class="line">        DotNew.Inner dni=dn.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-4内部类与向上转型"><a href="#10-4内部类与向上转型" class="headerlink" title="10.4	内部类与向上转型"></a>10.4	内部类与向上转型</h3><ul>
<li>外围类中添加实现接口的私有内部类，隐藏了实现的细节，有助于生成更高效的代码</li>
</ul>
<h3 id="10-5在方法和作用域内的内部类"><a href="#10-5在方法和作用域内的内部类" class="headerlink" title="10.5	在方法和作用域内的内部类"></a>10.5	在方法和作用域内的内部类</h3><ul>
<li><strong>内部类的作用</strong><ul>
<li>实现某类型的接口，创建并返回对其的引用</li>
<li>使用私有内部类辅助解决外围类的复杂问题</li>
</ul>
</li>
<li><strong>内部类的分类</strong><ul>
<li><strong>成员内部类</strong>：定义在一个类的内部，且在类的成员位置上。它可以访问外部类的所有成员变量和方法，包括私有的。创建成员内部类的实例时，必须先创建外部类的实例，通过外部类的引用来创建内部类的对象。</li>
<li><strong>静态内部类</strong>：定义在一个类的内部，且在类的成员位置上，并使用 static 修饰。它不能访问外部类的非静态成员变量和方法，只能访问外部类的静态成员变量和方法。创建静态内部类的实例时，不需要先创建外部类的实例。</li>
<li><strong>局部内部类</strong>：定义在一个方法或语句块的内部。它只能在定义它的方法或语句块中使用，并且不能被 public、protected、private 和 static 修饰。局部内部类可以访问外部类的所有成员变量和方法，但是要求这些变量和方法必须是 final 类型的。</li>
<li><strong>匿名内部类</strong>：没有类名的内部类。它通常用于创建临时的、只使用一次的类对象。匿名内部类通常作为参数传递给方法或构造函数，也可以直接创建它的实例。匿名内部类可以继承一个父类或实现一个接口，但是不能同时进行。</li>
</ul>
</li>
</ul>
<h3 id="10-6匿名内部类"><a href="#10-6匿名内部类" class="headerlink" title="10.6	匿名内部类"></a>10.6	匿名内部类</h3><ul>
<li><p><strong>匿名内部类</strong>：一个接口&#x2F;类的方法的某个实现方式在程序中只会执行一次，但为了使用它，我们需要创建它的实现类&#x2F;子类去实现&#x2F;重写，此时可以使用匿名内部类的方式，可以无需创建新的类，减少代码冗余</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        greeting.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-7嵌套类"><a href="#10-7嵌套类" class="headerlink" title="10.7	嵌套类"></a>10.7	嵌套类</h3><ul>
<li><p><strong>嵌套类</strong></p>
<ul>
<li><p>不需要其外围类的对象</p>
</li>
<li><p>不能从嵌套类的对象中访问非静态的外围类对象</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Greet</span> <span class="keyword">implements</span> <span class="title class_">Greeting</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Greet greet=<span class="keyword">new</span> <span class="title class_">Greet</span>();</span><br><span class="line">        greet.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>接口内部的类</strong>：嵌套类可以作为接口的一部分</p>
</li>
<li><p><strong>多层嵌套</strong>：无论被嵌套多少层，嵌套类都可以透明地访问它所嵌入的外围类的所有成员</p>
</li>
</ul>
<h3 id="10-8为什么需要内部类"><a href="#10-8为什么需要内部类" class="headerlink" title="10.8	为什么需要内部类"></a>10.8	为什么需要内部类</h3><ul>
<li><strong>内部类的作用</strong>：每个内部类都能够独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响</li>
<li><strong>内部类的特性</strong><ul>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建</li>
<li>内部类并没有令人迷惑的<strong>is-a</strong>关系，它就是一个独立的实体</li>
</ul>
</li>
<li><strong>闭包</strong>：一个可调用的对象，记录了来自于创建它的作用域的信息，内部类是面向对象的闭包</li>
<li><strong>回调</strong>：对象携带一些信息，允许它在稍后的某个时刻调用初始的对象</li>
</ul>
<h3 id="10-9内部类的继承"><a href="#10-9内部类的继承" class="headerlink" title="10.9	内部类的继承"></a>10.9	内部类的继承</h3><ul>
<li><p>内部类的继承需要使用**.super**，用于进行初始化操作</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WithInner</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritInner</span> <span class="keyword">extends</span> <span class="title class_">WithInner</span>.Inner&#123;</span><br><span class="line">    InheritInner(WithInner wi)&#123;</span><br><span class="line">        wi.<span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WithInner wi=<span class="keyword">new</span> <span class="title class_">WithInner</span>();</span><br><span class="line">        InheritInner ii=<span class="keyword">new</span> <span class="title class_">InheritInner</span>(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-10内部类可以被覆盖吗"><a href="#10-10内部类可以被覆盖吗" class="headerlink" title="10.10	内部类可以被覆盖吗"></a>10.10	内部类可以被覆盖吗</h3><ul>
<li>内部类可以被覆盖，但是仅继承外围类不会产生影响，因为它们位于两个不同的命名空间</li>
</ul>
<h3 id="10-11局部内部类"><a href="#10-11局部内部类" class="headerlink" title="10.11	局部内部类"></a>10.11	局部内部类</h3><ul>
<li>局部内部类不是外围类的一部分，但是它可以访问当前代码块的常量以及外围类的所有成员，与匿名内部类不同的是，局部内部类的对象可以被多次声明</li>
</ul>
<h3 id="10-12内部类标识符"><a href="#10-12内部类标识符" class="headerlink" title="10.12	内部类标识符"></a>10.12	内部类标识符</h3><ul>
<li>内部类会产生一个**.class<strong>文件以及包含它们的</strong>Class**对象信息，它们使用外围类名称 + $ + 内部类名称来命名</li>
</ul>
<h2 id="第十一章持有对象"><a href="#第十一章持有对象" class="headerlink" title="第十一章	持有对象"></a>第十一章	持有对象</h2><h3 id="11-1泛型和类型安全的容器"><a href="#11-1泛型和类型安全的容器" class="headerlink" title="11.1	泛型和类型安全的容器"></a>11.1	泛型和类型安全的容器</h3><ul>
<li>通过使用预定义的泛型，可以在编译期避免将错误类型的对象放置到容器中，同时也优化了后续的类型转换过程</li>
</ul>
<h3 id="11-2基本概念"><a href="#11-2基本概念" class="headerlink" title="11.2	基本概念"></a>11.2	基本概念</h3><ul>
<li><strong>Java</strong>容器类类库的用途为保存对象，可分为两类<ul>
<li><strong>Collection</strong>：一个独立元素的序列，服从一条或多条规则</li>
<li><strong>Map</strong>：一组成对的键值对对象，可以通过键来查找值</li>
</ul>
</li>
</ul>
<h3 id="11-3添加一组元素"><a href="#11-3添加一组元素" class="headerlink" title="11.3	添加一组元素"></a>11.3	添加一组元素</h3><ul>
<li><p><strong>添加元素</strong></p>
<ul>
<li><p>数组转换成集合<strong>asList</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Integer&gt; collection=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>向集合中添加多个元素<strong>addAll</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.addAll(collection,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>向集合中添加逐个元素<strong>add</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection.add(<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="11-4容器的打印"><a href="#11-4容器的打印" class="headerlink" title="11.4	容器的打印"></a>11.4	容器的打印</h3><ul>
<li><strong>容器打印</strong>：使用<strong>Arrays.toString</strong>来打印容器中的对象</li>
</ul>
<h3 id="11-5List"><a href="#11-5List" class="headerlink" title="11.5	List"></a>11.5	List</h3><ul>
<li><strong>List</strong>接口在<strong>Collection</strong>的基础上添加方法，使得它可以插入元素和移除元素<ul>
<li><strong>ArrayList</strong>：基于数组的容器，随机访问元素速度快，但是插入和移除元素较慢</li>
<li><strong>LinkedList</strong>：基于链表的容器，插入和删除操作较快，但随机访问能力低</li>
</ul>
</li>
</ul>
<h3 id="11-6迭代器"><a href="#11-6迭代器" class="headerlink" title="11.6	迭代器"></a>11.6	迭代器</h3><ul>
<li><strong>迭代器</strong>：一个对象，用于遍历并选择序列中的对象，不必关心序列底层的结构</li>
<li><strong>Iterator</strong>迭代器<ul>
<li>使用方法**iterator()**要求容器返回一个迭代器，将准备好返回序列的第一个元素</li>
<li>使用**next()**获得序列中的下一个元素</li>
<li>使用**hasNext()**检查序列中是否还有其他元素</li>
<li>使用**remove()**将迭代器新近返回的元素删除</li>
</ul>
</li>
<li><strong>ListIterator</strong>迭代器：<strong>Iterator</strong>迭代器的子类，允许双向移动</li>
</ul>
<h3 id="11-7LinkedList"><a href="#11-7LinkedList" class="headerlink" title="11.7	LinkedList"></a>11.7	LinkedList</h3><ul>
<li><strong>LinkedList</strong>：相对于<strong>ArrayList</strong>接口，性能上有所差异，同时添加了用作栈，队列或双端队列的方法</li>
</ul>
<h3 id="11-8Stack"><a href="#11-8Stack" class="headerlink" title="11.8	Stack"></a>11.8	Stack</h3><ul>
<li><strong>栈</strong>：后进先出的容器，可以通过<strong>LinkedList</strong>接口来实现</li>
</ul>
<h3 id="11-9Set"><a href="#11-9Set" class="headerlink" title="11.9	Set"></a>11.9	Set</h3><ul>
<li><strong>集合</strong>：不保存重复的元素，通常使用<strong>HashSet</strong>实现，在快速查找方面的性能较强</li>
</ul>
<h3 id="11-10Map"><a href="#11-10Map" class="headerlink" title="11.10	Map"></a>11.10	Map</h3><ul>
<li><strong>映射</strong>：将键对象映射到值对象，其中<strong>HashMap</strong>无序，而<strong>LinkedHashMap</strong>有序</li>
</ul>
<h3 id="11-11Queue"><a href="#11-11Queue" class="headerlink" title="11.11	Queue"></a>11.11	Queue</h3><ul>
<li><strong>队列</strong>：先进先出的容器，<strong>LinkedList</strong>是队列的一种实现</li>
<li><strong>PriorityQueue</strong>：优先级队列，确定元素的优先级，按照一定顺序弹出元素</li>
</ul>
<h3 id="11-12Collection和Iterator"><a href="#11-12Collection和Iterator" class="headerlink" title="11.12	Collection和Iterator"></a>11.12	Collection和Iterator</h3><ul>
<li><strong>Collection</strong>是描述所有序列容器的共性的根接口，但是，当我们需要实现一个不是<strong>Collection</strong>的类时，可以选择使用<strong>Iterator</strong>，在序列类上的约束也更少</li>
</ul>
<h3 id="11-13Foreach与迭代器"><a href="#11-13Foreach与迭代器" class="headerlink" title="11.13	Foreach与迭代器"></a>11.13	Foreach与迭代器</h3><ul>
<li><strong>foreach</strong>语法可用于任何<strong>Collection</strong>对象，它使用<strong>Iterator</strong>接口来返回序列中的元素</li>
<li><strong>适配器方法</strong>：添加一个用于生成迭代器的方法，提供接口以满足<strong>foreach</strong>语句</li>
</ul>
<h2 id="第十二章通过异常处理错误"><a href="#第十二章通过异常处理错误" class="headerlink" title="第十二章	通过异常处理错误"></a>第十二章	通过异常处理错误</h2><h3 id="12-1概念"><a href="#12-1概念" class="headerlink" title="12.1	概念"></a>12.1	概念</h3><ul>
<li><strong>异常处理的必要性</strong><ul>
<li>编译期间并不能找出所有的错误，余下的问题必须在运行期间解决</li>
<li>对于构造大型，健壮，可维护的程序而言，错误处理模式已经成为主要障碍</li>
<li>使用异常往往可以降低错误代码处理的复杂度</li>
</ul>
</li>
</ul>
<h3 id="12-2基本异常"><a href="#12-2基本异常" class="headerlink" title="12.2	基本异常"></a>12.2	基本异常</h3><ul>
<li><strong>异常情形</strong>：阻止当前方法或作用域据需执行的问题</li>
<li><strong>抛出异常的流程</strong><ul>
<li>使用<strong>new</strong>在堆上创建异常对象</li>
<li>当前执行路径被终止，并且从当前环境中弹出对异常对象的引用</li>
<li>异常处理机制接管程序，并寻找下一个合适的地方来继续执行程序</li>
</ul>
</li>
</ul>
<h3 id="12-3捕获异常"><a href="#12-3捕获异常" class="headerlink" title="12.3	捕获异常"></a>12.3	捕获异常</h3><ul>
<li><p><strong>try块</strong>：在块内设置监控区域，用于捕获可能出现的异常</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//Code that might generate exceptions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常处理程序</strong>：使用<strong>catch</strong>关键字，用于处理抛出的异常</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//Code that might generate exceptions</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type1 id1)&#123;</span><br><span class="line">	<span class="comment">//Handle exceptions of type1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type2 id2)&#123;</span><br><span class="line">	<span class="comment">//Handle exceptions of type2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//etc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>终止与恢复</strong>：异常处理的两种基本模型，<strong>Java</strong>支持终止模型，一旦被抛出，程序无法返回继续执行；另一种为恢复模型，异常处理程序修正错误，重新尝试出问题的方法</p>
</li>
</ul>
<h3 id="12-4创建自定义异常"><a href="#12-4创建自定义异常" class="headerlink" title="12.4	创建自定义异常"></a>12.4	创建自定义异常</h3><ul>
<li><strong>自定义异常类</strong>：选择意思相近的异常类进行继承</li>
<li><strong>异常与记录日志</strong>：将异常信息记录到<strong>Logger</strong>对象中</li>
</ul>
<h3 id="12-5异常说明"><a href="#12-5异常说明" class="headerlink" title="12.5	异常说明"></a>12.5	异常说明</h3><ul>
<li><strong>throw语句</strong>：将方法可能产生的异常抛出，并告知客户端程序员</li>
</ul>
<h3 id="12-6捕获所有异常"><a href="#12-6捕获所有异常" class="headerlink" title="12.6	捕获所有异常"></a>12.6	捕获所有异常</h3><ul>
<li><strong>Exception类</strong>：异常类型的基类，可以使用它捕获所有的异常，然后根据它的类型判断异常的原因</li>
<li><strong>栈轨迹</strong>：**printStackTree()<strong>和</strong>getStacktree()**可以将元素压入和取出栈</li>
<li><strong>重新抛出异常</strong>：使用<strong>throw</strong>语句重新抛出异常，将异常交给上一级异常处理程序，同一个<strong>try</strong>块的后续<strong>catch</strong>子句将被忽略</li>
<li><strong>异常链</strong>：在捕获一个异常后抛出另一个异常，并把原始异常的信息保存下来</li>
</ul>
<h3 id="12-7Java标准异常"><a href="#12-7Java标准异常" class="headerlink" title="12.7	Java标准异常"></a>12.7	Java标准异常</h3><ul>
<li><strong>Throwable类</strong>：表示任何可以作为异常被抛出的类，可分为编译时和系统错误<strong>Error</strong>和运行时错误<strong>Exception</strong></li>
<li><strong>RuntimeException类</strong>：运行时异常类，代表着编程错误</li>
</ul>
<h3 id="12-8使用finally进行清理"><a href="#12-8使用finally进行清理" class="headerlink" title="12.8	使用finally进行清理"></a>12.8	使用finally进行清理</h3><ul>
<li><strong>finally子句</strong>：无论<strong>try</strong>是否抛出异常，都能得到执行的子句，可以用来把除内存外的资源恢复到它们的初始状态，包括网络连接，图形和外部开关等</li>
<li>在<strong>return</strong>语句中使用<strong>finally</strong>：<strong>finally</strong>子句一定会执行，即使<strong>return</strong>先进行了返回操作，<strong>finally</strong>中的代码也会被执行</li>
</ul>
<h3 id="12-9异常的限制"><a href="#12-9异常的限制" class="headerlink" title="12.9	异常的限制"></a>12.9	异常的限制</h3><ul>
<li>在覆盖方法时，只能抛出在基类方法的异常说明中列出的异常，但是这种限制对构造器不起作用，且派生类构造器不能接收基类构造器抛出的异常</li>
</ul>
<h3 id="12-10构造器"><a href="#12-10构造器" class="headerlink" title="12.10	构造器"></a>12.10	构造器</h3><ul>
<li>当构造器抛出异常时，除内存外其他资源的清理工作不会进行，编写构造器时要格外小心</li>
</ul>
<h3 id="12-11异常匹配"><a href="#12-11异常匹配" class="headerlink" title="12.11	异常匹配"></a>12.11	异常匹配</h3><ul>
<li>抛出异常时，异常处理系统会按照代码的书写顺序找出最近的处理程序，匹配后就不再查找</li>
</ul>
<h3 id="12-12其他可选方式"><a href="#12-12其他可选方式" class="headerlink" title="12.12	其他可选方式"></a>12.12	其他可选方式</h3><ul>
<li><strong>异常处理历史</strong><ul>
<li>起源于<strong>Pl&#x2F;1</strong>和<strong>Mesa</strong>之类的系统</li>
<li>借鉴于<strong>CLU</strong>的做法，异常处理机制加入到**C++**标准化过程</li>
<li><strong>Java</strong>设计者去掉了一些<strong>C+<strong>中不好的地方，将异常处理机制加入到</strong>Java</strong>中</li>
</ul>
</li>
<li><strong>Java被检查的异常</strong><ul>
<li>一致的，使用异常来报告错误的模型</li>
<li>一定的类型检查，强制程序使用正确的类型</li>
</ul>
</li>
</ul>
<h3 id="12-13异常使用指南"><a href="#12-13异常使用指南" class="headerlink" title="12.13	异常使用指南"></a>12.13	异常使用指南</h3><ul>
<li><strong>使用异常的情况</strong><ul>
<li>在恰当的级别处理问题</li>
<li>解决问题并且重新调用产生异常的方法</li>
<li>进行少许修补，然后绕过异常发生的地方继续执行</li>
<li>用别的数据进行计算，用代替方法预计会返回的值</li>
<li>把当前环境能做的事情尽量做完，然后把相同的异常重抛到更高层</li>
<li>把当前环境能做的事情尽量做完，然后把不同的异常抛到更高层</li>
<li>终止程序</li>
<li>进行简化</li>
<li>让类库和程序更安全</li>
</ul>
</li>
</ul>
<h2 id="第十三章字符串"><a href="#第十三章字符串" class="headerlink" title="第十三章	字符串"></a>第十三章	字符串</h2><h3 id="13-1不可变String"><a href="#13-1不可变String" class="headerlink" title="13.1	不可变String"></a>13.1	不可变String</h3><ul>
<li><strong>String</strong>对象是不可改变的，任何修改<strong>String</strong>值的行为都是创建全新的<strong>String</strong>对象</li>
</ul>
<h3 id="13-2重载“-”与StringBuilder"><a href="#13-2重载“-”与StringBuilder" class="headerlink" title="13.2	重载“+”与StringBuilder"></a>13.2	重载“+”与StringBuilder</h3><ul>
<li><strong>Java</strong>重载了 <strong>+</strong> 和 <strong>+&#x3D;</strong> 运算符，用于字符串的连接，原理为重新生成所需的<strong>String</strong>对象</li>
<li>当循环修改<strong>String</strong>对象时，可以使用<strong>StringBuilder</strong>类来提高代码运行效率</li>
</ul>
<h3 id="13-3无意识的递归"><a href="#13-3无意识的递归" class="headerlink" title="13.3	无意识的递归"></a>13.3	无意识的递归</h3><ul>
<li>在代码中使用 <strong>+</strong> 时，可能会自动调用<strong>Object</strong>的<strong>toString</strong>方法而转化为<strong>String</strong>对象</li>
</ul>
<h3 id="13-4String上的操作"><a href="#13-4String上的操作" class="headerlink" title="13.4	String上的操作"></a>13.4	String上的操作</h3><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">参数，重载版本</th>
<th align="center">应用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">构造器</td>
<td align="center">默认版本，<strong>String</strong>，<strong>StringBuilder</strong>，<strong>StringBuffer</strong>，<strong>char</strong>数组，<strong>byte</strong>数组</td>
<td align="center">创建<strong>String</strong>对象</td>
</tr>
<tr>
<td align="center"><strong>length()</strong></td>
<td align="center"></td>
<td align="center"><strong>String</strong>中字符的个数</td>
</tr>
<tr>
<td align="center"><strong>charAt()</strong></td>
<td align="center"><strong>int</strong>索引</td>
<td align="center">取得<strong>String</strong>中该索引位置上的<strong>char</strong></td>
</tr>
<tr>
<td align="center"><strong>getChars(),getBytes()</strong></td>
<td align="center">复制部分起点终点的索引，目标数组，目标数组的起始索引</td>
<td align="center">复制<strong>char</strong>或<strong>byte</strong>到一个目标数组中</td>
</tr>
<tr>
<td align="center"><strong>toCharArray()</strong></td>
<td align="center"></td>
<td align="center">生成一个<strong>char[]<strong>，包含</strong>String</strong>的所有字符</td>
</tr>
<tr>
<td align="center"><strong>equals()</strong></td>
<td align="center">要比较的<strong>String</strong></td>
<td align="center">比较两个<strong>String</strong>的内容是否相同</td>
</tr>
<tr>
<td align="center"><strong>compareTo()</strong></td>
<td align="center">要比较的<strong>String</strong></td>
<td align="center">按词典顺序比较<strong>String</strong>的内容</td>
</tr>
<tr>
<td align="center"><strong>contains()</strong></td>
<td align="center">要搜索的<strong>CharSequence</strong></td>
<td align="center">判断<strong>String</strong>对象是否包含参数的内容</td>
</tr>
<tr>
<td align="center"><strong>contentEquals()</strong></td>
<td align="center">要比较的<strong>CharSequence</strong>或<strong>StringBuffer</strong></td>
<td align="center">判断<strong>String</strong>对象是否与参数的内容完全一致</td>
</tr>
<tr>
<td align="center"><strong>equalsIgnoreCase()</strong></td>
<td align="center">要比较的<strong>String</strong></td>
<td align="center">忽略大小写，判断<strong>String</strong>内容是否相同</td>
</tr>
<tr>
<td align="center"><strong>regionMatcher()</strong></td>
<td align="center">两个<strong>String</strong>的索引偏移量，要比较的长度，重载版本可以忽略大小写</td>
<td align="center">判断所选区域是否相等</td>
</tr>
<tr>
<td align="center"><strong>startsWith</strong></td>
<td align="center">起始<strong>String</strong>，重载版本增加了偏移量</td>
<td align="center">判断此参数是否为字符串的前缀</td>
</tr>
<tr>
<td align="center"><strong>endsWith</strong></td>
<td align="center">后缀<strong>String</strong></td>
<td align="center">判断此参数是否为字符串的后缀</td>
</tr>
<tr>
<td align="center"><strong>indexOf(),lastIndexOf()</strong></td>
<td align="center">重载版本有<strong>char</strong>，<strong>char</strong>与起始索引，<strong>String</strong>，<strong>String</strong>与起始索引</td>
<td align="center">返回此参数在<strong>String</strong>中的起始索引，不包含则返回-1,**lastIndexOf()**是从后向前搜索</td>
</tr>
<tr>
<td align="center"><strong>substring(),(subSequence())</strong></td>
<td align="center">重载版本有起始索引，起始索引 + 终点坐标</td>
<td align="center">返回包含参数的子字符串</td>
</tr>
<tr>
<td align="center"><strong>concat()</strong></td>
<td align="center">要连接的<strong>String</strong></td>
<td align="center">连接后的新的<strong>String</strong>对象</td>
</tr>
<tr>
<td align="center"><strong>replace()</strong></td>
<td align="center">要替换掉的<strong>char</strong>或<strong>charSequence</strong>，用来替换的<strong>char</strong>或<strong>charSequence</strong></td>
<td align="center">替换字符后的新<strong>String</strong>对象</td>
</tr>
<tr>
<td align="center"><strong>toLowerCase(),toUpperCase()</strong></td>
<td align="center"></td>
<td align="center">大小写转换后的新<strong>String</strong>对象</td>
</tr>
<tr>
<td align="center"><strong>trim()</strong></td>
<td align="center"></td>
<td align="center">删除两端空白符后的新<strong>String</strong>对象</td>
</tr>
<tr>
<td align="center"><strong>valueOf()</strong></td>
<td align="center">重载版本有<strong>Object</strong>，<strong>char[]<strong>，</strong>char[]<strong>和偏移量和字符个数，</strong>boolean</strong>,<strong>char</strong>,<strong>int</strong>，<strong>long</strong>，<strong>float</strong>，<strong>double</strong></td>
<td align="center">表示参数内容的<strong>String</strong></td>
</tr>
<tr>
<td align="center"><strong>intern()</strong></td>
<td align="center"></td>
<td align="center">为每一个唯一的字符序列生成一个且仅生成一个<strong>String</strong>引用</td>
</tr>
</tbody></table>
<h3 id="13-5格式化输出"><a href="#13-5格式化输出" class="headerlink" title="13.5	格式化输出"></a>13.5	格式化输出</h3><ul>
<li>**printf()**：格式化修饰符 + 参数</li>
<li><strong>System.out.format()<strong>：与C语言的</strong>printf()<strong>和</strong>Java</strong>中的**System.out.printf()**等价</li>
<li><strong>Formatter</strong>类：<strong>Java</strong>中的所有的格式化功能都由该类实现</li>
<li><strong>格式化说明符</strong>：**%[argument_index$][flags][width][.precision]conversion**<ul>
<li>**[width]**：指定一个域的最小尺寸，默认添加空格右对齐</li>
<li>**[.precision]**：指定最大尺寸</li>
</ul>
</li>
<li><strong>Formatter转换</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型转换字符</th>
<th align="center">字符含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">d</td>
<td align="center">整数型（十进制）</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">Unicode字符</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">Boolean值</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">String</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">浮点数（十进制）</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">浮点数（科学计数法）</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">整数（十六进制）</td>
</tr>
<tr>
<td align="center">h</td>
<td align="center">散列码（十六进制）</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">字符%</td>
</tr>
</tbody></table>
<h3 id="13-6正则表达式"><a href="#13-6正则表达式" class="headerlink" title="13.6	正则表达式"></a>13.6	正则表达式</h3><ul>
<li><p><strong>正则表达式</strong>：一种强大而灵活的文本处理工具，以编程的方式，构造复杂的文本模式，并对输入的字符串进行搜索</p>
</li>
<li><p><strong>创建正则表达式</strong></p>
<ul>
<li><p>字符</p>
<table>
<thead>
<tr>
<th align="center">正则表达式</th>
<th align="center">匹配内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">指定字符B</td>
</tr>
<tr>
<td align="center">\xhh</td>
<td align="center">十六进制中值为0xhh的字符</td>
</tr>
<tr>
<td align="center">\uhhhh</td>
<td align="center">十六进制表示0xhhhh的Unicode字符</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">制表符Tab</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">换行符</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">回车</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">换页</td>
</tr>
<tr>
<td align="center">\e</td>
<td align="center">转义</td>
</tr>
</tbody></table>
</li>
<li><p>字符类</p>
<table>
<thead>
<tr>
<th align="center">正则表达式</th>
<th align="center">匹配内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="center">任意字符</td>
</tr>
<tr>
<td align="center">[abc]</td>
<td align="center">包含a，b和c的任意字符</td>
</tr>
<tr>
<td align="center">[^abc]</td>
<td align="center">除了a，b，c外的任何字符</td>
</tr>
<tr>
<td align="center">[a-zA-Z]</td>
<td align="center">从a到z或从A到Z的任意字符</td>
</tr>
<tr>
<td align="center">[abc[hij]]</td>
<td align="center">任意a，b，c，h，i，j字符</td>
</tr>
<tr>
<td align="center">[a-z&amp;&amp;[hij]]</td>
<td align="center">任意h，i，j字符</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">空白符</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">非空白符</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">数字0-9</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="center">非数字</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">词字符（大小写字母，数字）</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">非词字符</td>
</tr>
</tbody></table>
</li>
<li><p>逻辑操作符</p>
<table>
<thead>
<tr>
<th align="center">正则表达式</th>
<th align="center">匹配内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">XY</td>
<td align="center">Y在X后面</td>
</tr>
<tr>
<td align="center">X|Y</td>
<td align="center">X或Y</td>
</tr>
<tr>
<td align="center">（X）</td>
<td align="center">捕获组，使用\i引用第i个捕获组</td>
</tr>
</tbody></table>
</li>
<li><p>边界匹配符</p>
<table>
<thead>
<tr>
<th align="center">正则表达式</th>
<th align="center">匹配内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="center">一行的起始</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">一行的结束</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">词的边界</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">非词的边界</td>
</tr>
<tr>
<td align="center">\G</td>
<td align="center">前一个匹配的结束</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>量词</strong>：描述一个模式吸收输入文本的方式</p>
<ul>
<li><strong>贪婪型</strong>：为所有可能的模式发现尽可能多的匹配</li>
<li><strong>勉强型</strong>：匹配满足模式所需的最少字符数</li>
<li><strong>占有型</strong>：仅用于<strong>Java</strong>语言，不保存中间状态，防止回溯，常用于防止正则表达式失控</li>
</ul>
<table>
<thead>
<tr>
<th align="center">贪婪型</th>
<th align="center">勉强型</th>
<th align="center">占有型</th>
<th align="center">如何匹配</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X?</td>
<td align="center">X??</td>
<td align="center">X?+</td>
<td align="center">一个或零个X</td>
</tr>
<tr>
<td align="center">X*</td>
<td align="center">X*?</td>
<td align="center">X*+</td>
<td align="center">零个或多个X</td>
</tr>
<tr>
<td align="center">X+</td>
<td align="center">X+?</td>
<td align="center">X++</td>
<td align="center">一个或多个X</td>
</tr>
<tr>
<td align="center">X{n}</td>
<td align="center">X{n}?</td>
<td align="center">X{n}+</td>
<td align="center">恰好n次X</td>
</tr>
<tr>
<td align="center">X{n,}</td>
<td align="center">X{n,}?</td>
<td align="center">X{n,}+</td>
<td align="center">至少n次X</td>
</tr>
<tr>
<td align="center">X{n,m}</td>
<td align="center">X{n,m}?</td>
<td align="center">X{n,m}+</td>
<td align="center">X至少n次，且不超过mci</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Pattern和Matcher</strong>：<strong>Pattern</strong>类表示一个正则表达式，可以通过<strong>Pattern.compile()<strong>方法将一个字符串编译成一个</strong>Pattern</strong>对象，<strong>Matcher</strong>类则是用于匹配字符串的工具类，可以通过<strong>Pattern.matcher()<strong>方法将一个字符串与一个</strong>Pattern</strong>对象进行匹配</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String regex=<span class="string">&quot;x+&quot;</span>;</span><br><span class="line">String input=<span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">Pattern pattern=Pattern.compile(regex);</span><br><span class="line">Matcher matcher=pattern.matcher(input);</span><br><span class="line">System.out.println(matcher);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="13-7扫描输入"><a href="#13-7扫描输入" class="headerlink" title="13.7	扫描输入"></a>13.7	扫描输入</h3><ul>
<li><strong>扫描输入</strong>：使用<strong>Scanner</strong>类，接受任何类型的输入对象，通过正则表达式扫描，获取所需输入</li>
</ul>
<h2 id="第十四章类型信息"><a href="#第十四章类型信息" class="headerlink" title="第十四章	类型信息"></a>第十四章	类型信息</h2><h3 id="14-1为什么需要RTTI"><a href="#14-1为什么需要RTTI" class="headerlink" title="14.1	为什么需要RTTI"></a>14.1	为什么需要RTTI</h3><ul>
<li><strong>RTTI</strong>：在运行时，识别一个对象的类型</li>
</ul>
<h3 id="14-2Class对象"><a href="#14-2Class对象" class="headerlink" title="14.2	Class对象"></a>14.2	Class对象</h3><ul>
<li><p><strong>Class对象</strong>：一种特殊的对象，包含了与类有关的信息，每当编译一个新类，<strong>JVM</strong>使用类加载器生成一个<strong>Class</strong>对象</p>
</li>
<li><p><strong>动态加载</strong></p>
<ul>
<li>当程序创建第一个对类的静态成员的引用时，就会加载这个类</li>
<li><strong>Java</strong>程序在它运行之前并未被完全加载，各部分只有在必需的时候才会被加载</li>
<li>类加载器首先检查<strong>Class</strong>对象是否已经被加载，如果没有，类加载器根据类名查找**.class<strong>文件加载</strong>.Class**对象</li>
</ul>
</li>
<li><p><strong>类字面量</strong>：生成对**.Class**对象的引用</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FancyToy.class</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用类的准备工作</strong></p>
<ul>
<li><strong>加载</strong>，由类加载器执行，查找字节码并创建 <strong>Class</strong>对象</li>
<li><strong>链接</strong>，验证类中的字节码，为静态域分配空间，解析在该类创建的对其他类的引用</li>
<li><strong>初始化</strong>，执行静态初始化器和静态初始化块</li>
</ul>
</li>
</ul>
<h3 id="14-3类型转换前先做检查"><a href="#14-3类型转换前先做检查" class="headerlink" title="14.3	类型转换前先做检查"></a>14.3	类型转换前先做检查</h3><ul>
<li><p><strong>instanceof关键字</strong>：返回一个布尔值，表示对象是不是某个特定类型的实例</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Dog) ((Dog)x).bark();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="14-4注册工厂"><a href="#14-4注册工厂" class="headerlink" title="14.4	注册工厂"></a>14.4	注册工厂</h3><ul>
<li>使用工厂设计模式，将对象的创建工作交由类来完成，工厂被多态地调用而创建恰当的对象</li>
</ul>
<h3 id="14-5instanceof与Class的等价性"><a href="#14-5instanceof与Class的等价性" class="headerlink" title="14.5	instanceof与Class的等价性"></a>14.5	instanceof与Class的等价性</h3><ul>
<li><strong>instance</strong>和<strong>Class</strong>：<strong>instance</strong>判断是否为比较类或者比较类的基类，<strong>Class</strong>仅仅判断是否为比较类</li>
</ul>
<h3 id="14-6反射：运行时的类信息"><a href="#14-6反射：运行时的类信息" class="headerlink" title="14.6	反射：运行时的类信息"></a>14.6	反射：运行时的类信息</h3><ul>
<li><strong>反射机制</strong>：当某个对象的类型在编译时未知，需要在程序运行时获取对象的类型时，传统的<strong>RTTI</strong>无法识别，可以通过在<strong>JVM</strong>创建的<strong>Class</strong>对象和<strong>Java.lang.reflect</strong>类库的反射类获知对象的类型，并进行相关的操作</li>
<li><strong>类方法提取器</strong>：使用<strong>Class</strong>的<strong>getMethods()<strong>和</strong>getConstructors()<strong>方法来得到</strong>Method</strong>对象的数组和<strong>Constructor</strong>对象的数组，分别解析对象的方法和构造器，包括其名字，输入参数以及返回值</li>
</ul>
<h3 id="14-7动态代理"><a href="#14-7动态代理" class="headerlink" title="14.7	动态代理"></a>14.7	动态代理</h3><ul>
<li><strong>代理</strong>：基本的设计模式之一，为了提供额外的或不同的操作，而插入用来替代实际对象的对象，通常涉及与实际对象的通信，代理起到中间人的角色</li>
</ul>
<h3 id="14-8空对象"><a href="#14-8空对象" class="headerlink" title="14.8	空对象"></a>14.8	空对象</h3><ul>
<li>使用空对象<strong>null</strong>表示缺少对象</li>
</ul>
<h3 id="14-9接口与类型信息"><a href="#14-9接口与类型信息" class="headerlink" title="14.9	接口与类型信息"></a>14.9	接口与类型信息</h3><ul>
<li><strong>instance</strong>关键字允许程序员隔离构件，从而减低代码的耦合度，可以被应用到接口中</li>
</ul>
<h2 id="第十五章泛型"><a href="#第十五章泛型" class="headerlink" title="第十五章	泛型"></a>第十五章	泛型</h2><h3 id="15-1与C-的比较"><a href="#15-1与C-的比较" class="headerlink" title="15.1	与C++的比较"></a>15.1	与C++的比较</h3><ul>
<li><strong>泛型</strong>：实现了参数化的概念，使得代码可以应用于更多的类型，类和方法能够具备更广泛的表达能力</li>
</ul>
<h3 id="15-2简单泛型"><a href="#15-2简单泛型" class="headerlink" title="15.2	简单泛型"></a>15.2	简单泛型</h3><ul>
<li><p>创造容器类，指定容器要持有特定类型对象，并且由编译器来保证类型的安全</p>
</li>
<li><p><strong>元组</strong>：将一组对象打包存储于其中的一个单一对象，可以具有任意长度，存储任意类型</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tuple&lt;String, Integer&gt; tuple = <span class="keyword">new</span> <span class="title class_">Tuple</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="15-3泛型接口"><a href="#15-3泛型接口" class="headerlink" title="15.3	泛型接口"></a>15.3	泛型接口</h3><ul>
<li>泛型可以应用于接口，例如工厂方法设计模式中专门负责创建对象的生成器</li>
</ul>
<h3 id="15-4泛型方法"><a href="#15-4泛型方法" class="headerlink" title="15.4	泛型方法"></a>15.4	泛型方法</h3><ul>
<li><p><strong>泛型方法</strong>：一种类型安全的方法，它可以在声明方法时使用一个或多个参数来占位符，这些占位符称为<strong>类型形参</strong>，可代表任何<strong>Java</strong>数据类型，在调用方法时需要指定实际类型的参数</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(T x)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>杠杆</p>
</li>
</ul>
<h3 id="15-5匿名内部类"><a href="#15-5匿名内部类" class="headerlink" title="15.5	匿名内部类"></a>15.5	匿名内部类</h3><h3 id="15-6构建复杂模型"><a href="#15-6构建复杂模型" class="headerlink" title="15.6	构建复杂模型"></a>15.6	构建复杂模型</h3><h3 id="15-7擦出的神秘之处"><a href="#15-7擦出的神秘之处" class="headerlink" title="15.7	擦出的神秘之处"></a>15.7	擦出的神秘之处</h3><h3 id="15-8擦除的补偿"><a href="#15-8擦除的补偿" class="headerlink" title="15.8	擦除的补偿"></a>15.8	擦除的补偿</h3><h3 id="15-9边界"><a href="#15-9边界" class="headerlink" title="15.9	边界"></a>15.9	边界</h3><h3 id="15-10通配符"><a href="#15-10通配符" class="headerlink" title="15.10	通配符"></a>15.10	通配符</h3><h3 id="15-11问题"><a href="#15-11问题" class="headerlink" title="15.11	问题"></a>15.11	问题</h3><h3 id="15-12自限定的类型"><a href="#15-12自限定的类型" class="headerlink" title="15.12	自限定的类型"></a>15.12	自限定的类型</h3><h3 id="15-13动态类型安全"><a href="#15-13动态类型安全" class="headerlink" title="15.13	动态类型安全"></a>15.13	动态类型安全</h3><h3 id="15-14异常"><a href="#15-14异常" class="headerlink" title="15.14	异常"></a>15.14	异常</h3><h3 id="15-15混型"><a href="#15-15混型" class="headerlink" title="15.15	混型"></a>15.15	混型</h3><h3 id="15-16潜在类型机制"><a href="#15-16潜在类型机制" class="headerlink" title="15.16	潜在类型机制"></a>15.16	潜在类型机制</h3><h3 id="15-17对缺乏潜在类型机制的补偿"><a href="#15-17对缺乏潜在类型机制的补偿" class="headerlink" title="15.17	对缺乏潜在类型机制的补偿"></a>15.17	对缺乏潜在类型机制的补偿</h3><h3 id="15-18将函数对象用作策略"><a href="#15-18将函数对象用作策略" class="headerlink" title="15.18	将函数对象用作策略"></a>15.18	将函数对象用作策略</h3><h3 id="15-19总结：转型真的如此之糟吗？"><a href="#15-19总结：转型真的如此之糟吗？" class="headerlink" title="15.19	总结：转型真的如此之糟吗？"></a>15.19	总结：转型真的如此之糟吗？</h3><h2 id="第十六章数组"><a href="#第十六章数组" class="headerlink" title="第十六章	数组"></a>第十六章	数组</h2><h3 id="16-1数组为什么特殊"><a href="#16-1数组为什么特殊" class="headerlink" title="16.1	数组为什么特殊"></a>16.1	数组为什么特殊</h3><ul>
<li><strong>数组的特殊</strong><ul>
<li>效率最高的存储和随机访问对象引用序列的方式，简单的线性结构使得元素访问十分迅速</li>
<li>在不使用泛型的情况下，数组只能持有某特定类型的对象，错误的类型无法通过编译器检查</li>
<li>数组可以持有基本类型</li>
</ul>
</li>
</ul>
<h3 id="16-2数组是第一级对象"><a href="#16-2数组是第一级对象" class="headerlink" title="16.2	数组是第一级对象"></a>16.2	数组是第一级对象</h3><ul>
<li><p>数组标识符只有一个引用，指向在堆中创建的一个真实的对象，用于保存指向其他对象的引用</p>
</li>
<li><p><strong>初始化数组</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a;</span><br><span class="line"><span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>[] c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="16-3返回一个数组"><a href="#16-3返回一个数组" class="headerlink" title="16.3	返回一个数组"></a>16.3	返回一个数组</h3><ul>
<li>在<strong>c&#x2F;c++<strong>中，只能返回指向数组的指针，而</strong>Java</strong>可以直接返回数组本身，类似于普通的对象</li>
</ul>
<h3 id="16-4多维数组"><a href="#16-4多维数组" class="headerlink" title="16.4	多维数组"></a>16.4	多维数组</h3><ul>
<li><p><strong>创建多维数组</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] a = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span>[][] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>粗糙数组</strong>：数组中构成矩阵的每个向量都可以具有任意的长度</p>
</li>
<li><p>**Arrays.deepTostring()**：将多维数组转化为字符串</p>
</li>
</ul>
<h3 id="16-5数组与泛型"><a href="#16-5数组与泛型" class="headerlink" title="16.5	数组与泛型"></a>16.5	数组与泛型</h3><ul>
<li>数组与泛型不能很好地结合，但是可以参数化数组本身的类型</li>
</ul>
<h3 id="16-6创建测试数据"><a href="#16-6创建测试数据" class="headerlink" title="16.6	创建测试数据"></a>16.6	创建测试数据</h3><ul>
<li>**Arrays.fill()**：复制同一个值填充整个数组</li>
<li><strong>数据生成器</strong>：使用<strong>Generator</strong>类，以更灵活的方式创建数组</li>
</ul>
<h3 id="16-7Arrays实用功能"><a href="#16-7Arrays实用功能" class="headerlink" title="16.7	Arrays实用功能"></a>16.7	Arrays实用功能</h3><ul>
<li><strong>复制数组</strong>：相对于<strong>for</strong>语句，**System.arraycopy()**可以更快地进行浅复制</li>
<li><strong>数组的比较</strong>：使用重载后的**equals()**方法比较整个数组</li>
<li><strong>数组元素的比较</strong>：通过实现了<strong>Comparable</strong>接口的<strong>compareTo</strong>方法比较元素，或者编写自己的<strong>Comparator</strong>方法进行比较</li>
<li><strong>数组排序</strong>：使用内置的排序方法对基本类型的数组进行排序，或者对实现了<strong>Comparable</strong>接口的对象进行排序</li>
<li><strong>在已排序的数组中查找</strong>：使用**Arrays.binarySearch()**方法进行快速的二分查找</li>
</ul>
<h2 id="第十七章容器深入研究"><a href="#第十七章容器深入研究" class="headerlink" title="第十七章	容器深入研究"></a>第十七章	容器深入研究</h2><h3 id="17-1完整的容器分类法"><a href="#17-1完整的容器分类法" class="headerlink" title="17.1	完整的容器分类法"></a>17.1	完整的容器分类法</h3><h3 id="17-2填充容器"><a href="#17-2填充容器" class="headerlink" title="17.2	填充容器"></a>17.2	填充容器</h3><ul>
<li>**fill()**：复制同一个对象引用来填充整个容器</li>
<li><strong>Generator类</strong>：适配器设计模式，使用该类来填充容器</li>
</ul>
<h3 id="17-3Collection的功能方法"><a href="#17-3Collection的功能方法" class="headerlink" title="17.3	Collection的功能方法"></a>17.3	Collection的功能方法</h3><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>boolean add(T)</strong></td>
<td align="center">将参数添加进容器</td>
</tr>
<tr>
<td align="center"><strong>boolean addAll(Collections&lt;? extends T&gt;)</strong></td>
<td align="center">添加参数中的所有元素</td>
</tr>
<tr>
<td align="center"><strong>void clear()</strong></td>
<td align="center">移除容器中的所有元素</td>
</tr>
<tr>
<td align="center"><strong>boolean contains(T)</strong></td>
<td align="center">判断容器是否持有特定类型</td>
</tr>
<tr>
<td align="center"><strong>boolean containsAll(Collection&lt;?&gt;)</strong></td>
<td align="center">判断容器是否持有此类型的所有元素</td>
</tr>
<tr>
<td align="center"><strong>boolean isEmpty()</strong></td>
<td align="center">判断容器是否为空</td>
</tr>
<tr>
<td align="center"><strong>Iterator&lt;T&gt; iterator()</strong></td>
<td align="center">返回容器的迭代器</td>
</tr>
<tr>
<td align="center"><strong>boolean remove(Object)</strong></td>
<td align="center">移除一个元素</td>
</tr>
<tr>
<td align="center"><strong>boolean removeAll(Collection&lt;?&gt;)</strong></td>
<td align="center">移除参数中的所有元素</td>
</tr>
<tr>
<td align="center"><strong>boolean containsAll(Collection&lt;?&gt;)</strong></td>
<td align="center">只保存参数中的元素</td>
</tr>
<tr>
<td align="center"><strong>int size()</strong></td>
<td align="center">容器中元素数目</td>
</tr>
<tr>
<td align="center"><strong>Object[] toArray()</strong></td>
<td align="center">返回容器元素转化的数组</td>
</tr>
<tr>
<td align="center"><strong>&lt;T&gt; T[] toArray(T[] a)</strong></td>
<td align="center">返回容器元素转化的指定类型的数组</td>
</tr>
</tbody></table>
<h3 id="17-4可选操作"><a href="#17-4可选操作" class="headerlink" title="17.4	可选操作"></a>17.4	可选操作</h3><ul>
<li><strong>可选操作</strong>：在<strong>Collection</strong>接口中执行各种不同的添加和移除的方法是可选的，实现类并不需要为这些方法提供功能定义</li>
<li><strong>未获支持的操作</strong>：<strong>Java</strong>程序中使用了一些不被支持或不被推荐的操作或语法</li>
</ul>
<h3 id="17-5List的功能方法"><a href="#17-5List的功能方法" class="headerlink" title="17.5	List的功能方法"></a>17.5	List的功能方法</h3><ul>
<li><strong>List</strong>类基本方法<ul>
<li>**add()**：添加元素</li>
<li>**get()**：获取元素</li>
<li>**iterator()**：返回迭代器</li>
</ul>
</li>
</ul>
<h3 id="17-6Set和存储顺序"><a href="#17-6Set和存储顺序" class="headerlink" title="17.6	Set和存储顺序"></a>17.6	Set和存储顺序</h3><ul>
<li><p><strong>Set类的分类</strong></p>
<table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Set</strong></td>
<td align="center">元素具有唯一性，不保证维护元素的次序</td>
</tr>
<tr>
<td align="center"><strong>HashSet</strong></td>
<td align="center">适用于快速查找，存入元素必须定义**hashCode()**方法</td>
</tr>
<tr>
<td align="center"><strong>TreeSet</strong></td>
<td align="center">保持元素的次序，底层为树结构，存入元素必须实现<strong>Comparable</strong>接口</td>
</tr>
<tr>
<td align="center"><strong>LinkedHashSet</strong></td>
<td align="center">具有<strong>HashSet</strong>的查找速度，且底层使用链表维护元素的次序，存入元素必须定义**hashCode()**方法</td>
</tr>
</tbody></table>
</li>
<li><p><strong>SortedSet</strong>：元素保证处于排序状态，按对象的比较函数对元素排序</p>
<ul>
<li><strong>Comparator comparator()<strong>：返回当前</strong>Set</strong>使用的<strong>Comparator</strong></li>
<li>**Object first()**：返回容器中第一个元素</li>
<li>**Object last()**：返回容器中最末的元素</li>
<li><strong>SortedSet subSet(fromElement, toElement)<strong>：生成此</strong>Set</strong>的子集，从<strong>fromElement</strong>到<strong>toElement</strong></li>
<li><strong>SortedSet headSet(toElement)<strong>：生成此</strong>Set</strong>的子集，从开始到<strong>toElement</strong></li>
<li><strong>SortedSet tailSet(fromElement)<strong>：生成此</strong>Set</strong>的子集，从<strong>fromElement</strong>到末尾</li>
</ul>
</li>
</ul>
<h3 id="17-7队列"><a href="#17-7队列" class="headerlink" title="17.7	队列"></a>17.7	队列</h3><ul>
<li><strong>优先级队列PriorityQueue</strong>：通过实现<strong>Comparable</strong>对元素进行排序</li>
<li><strong>双向队列</strong>：创建<strong>Deque</strong>类，基于<strong>LinkedList</strong>添加支持双向队列的相关方法</li>
</ul>
<h3 id="17-8理解Map"><a href="#17-8理解Map" class="headerlink" title="17.8	理解Map"></a>17.8	理解Map</h3><ul>
<li><p>映射表的思想是维护它的键-值对关联，基本方法是**put()<strong>和</strong>get()**，用于添加和取出键-值</p>
</li>
<li><p><strong>性能</strong></p>
<table>
<thead>
<tr>
<th align="center">类名</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>HashMap</strong></td>
<td align="center">基于散列表的实现，插入和查询的开销是固定的</td>
</tr>
<tr>
<td align="center"><strong>LinkedHashMap</strong></td>
<td align="center">类似于<strong>HashMap</strong>，使用链表维护内部次序，迭代遍历的速度更快，使用插入次序或<strong>LRU</strong>算法取得键值对</td>
</tr>
<tr>
<td align="center"><strong>TreeMap</strong></td>
<td align="center">基于红黑树的实现，查询是得到的结果会被经过排序</td>
</tr>
<tr>
<td align="center"><strong>WeakHashMap</strong></td>
<td align="center">弱键映射，允许释放映射所指向的对象</td>
</tr>
<tr>
<td align="center"><strong>ConcurrentHashMap</strong></td>
<td align="center">线程安全，不涉及同步加锁</td>
</tr>
<tr>
<td align="center"><strong>IdentityHashMap</strong></td>
<td align="center">使用**&#x3D;&#x3D;<strong>代替</strong>equals()**对键进行比较的散列映射</td>
</tr>
</tbody></table>
</li>
<li><p><strong>SortedMap</strong>：实现<strong>Comparable</strong>，确保键处于排序状态</p>
</li>
<li><p><strong>LinkedHashMap</strong>：散列化所有元素，提高速度，在遍历键值对时，以元素插入顺序返回</p>
</li>
</ul>
<h3 id="17-9散列与散列码"><a href="#17-9散列与散列码" class="headerlink" title="17.9	散列与散列码"></a>17.9	散列与散列码</h3><ul>
<li><p>**hashCode()**：返回对象的散列码，用于确定对象的存储位置，它根据对象的属性计算出一个整数值，尽可能地唯一标识对象</p>
</li>
<li><p><strong>为速度而散列</strong>：线性查询是最慢的查询方式，散列通过键对象生成散列码，使用散列码查询数组，使得查询得以快速进行</p>
</li>
<li><p><strong>计算散列码</strong></p>
<table>
<thead>
<tr>
<th align="center">域类型</th>
<th align="center">计算</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>boolean</strong></td>
<td align="center"><strong>c &#x3D; (f ? 0 : 1)</strong></td>
</tr>
<tr>
<td align="center"><strong>byte</strong>，<strong>char</strong>，<strong>short</strong>或<strong>int</strong></td>
<td align="center"><strong>c &#x3D; (int) f</strong></td>
</tr>
<tr>
<td align="center"><strong>long</strong></td>
<td align="center"><strong>c &#x3D; (int)(f ^ (f &gt;&gt;&gt; 32))</strong></td>
</tr>
<tr>
<td align="center"><strong>float</strong></td>
<td align="center"><strong>c &#x3D; Float.floatToIntBits(f)</strong></td>
</tr>
<tr>
<td align="center"><strong>double</strong></td>
<td align="center"><strong>long l &#x3D; Double.doubleToLongBits(f) ;</strong><br><strong>c &#x3D; (int)(l ^ (l &gt;&gt;&gt; 32))</strong></td>
</tr>
<tr>
<td align="center"><strong>Object</strong></td>
<td align="center"><strong>c &#x3D; f.hashCode()</strong></td>
</tr>
<tr>
<td align="center"><strong>数组</strong></td>
<td align="center"><strong>对每个元素应用上述规则</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="17-10选择接口的不同实现"><a href="#17-10选择接口的不同实现" class="headerlink" title="17.10	选择接口的不同实现"></a>17.10	选择接口的不同实现</h3><ul>
<li><strong>性能测试框架</strong>：编写测试框架，使用基类嵌套 多个测试匿名内部类的方式，对各个子程序进行性能测试</li>
<li><strong>微基准测试的危险</strong>：不能做太多的假设，并且要把测试窄化，同时考虑测试时间和测试环境对结果的影响</li>
</ul>
<h3 id="17-11实用方法"><a href="#17-11实用方法" class="headerlink" title="17.11	实用方法"></a>17.11	实用方法</h3><ul>
<li><strong>List的排序和查询</strong>：与数组类似，可以使用<strong>Collection</strong>的**sort()<strong>和</strong>binarysearch()<strong>分别进行排序和查询，此外，还可以使用</strong>shuffle()**打乱顺序</li>
<li><strong>设置Collection或Map为不可修改</strong>：设置只读类，参数为原本的容器，但返回值为容器的只读版本</li>
<li><strong>Collection或Map的同步控制</strong>：使用<strong>synchronize</strong>关键字自动同步整个容器，<strong>Java</strong>容器类使用快速报错机制，防止多线程产生的内容不一致问题</li>
</ul>
<h3 id="17-12持有引用"><a href="#17-12持有引用" class="headerlink" title="17.12	持有引用"></a>17.12	持有引用</h3><ul>
<li><strong>Reference类</strong>：作为与普通引用之间的代理，持有对某个对象的引用，避免被垃圾回收器回收后无法访问到该对象</li>
<li><strong>WeakHashMap类</strong>：用于保存<strong>WeakReference</strong>，使得规范映射更易于使用，每个值只保存一份实例以节省存储空间</li>
</ul>
<h3 id="17-13Java-1-0-1-1的容器"><a href="#17-13Java-1-0-1-1的容器" class="headerlink" title="17.13	Java 1.0&#x2F;1.1的容器"></a>17.13	Java 1.0&#x2F;1.1的容器</h3><ul>
<li><strong>Vector类</strong>：类似于<strong>ArrayList</strong>，但是缺点较多，建议使用<strong>ArrayList</strong>替代</li>
<li><strong>Enumeration接口</strong>：类似于<strong>Iterator</strong>接口，只有两个方法</li>
<li><strong>Hashtable类</strong>：与<strong>HashMap</strong>很相似，建议使用<strong>HashMap</strong>替代</li>
<li><strong>Stack类</strong>：继承<strong>Vector</strong>而实现栈的功能，建议使用或继承<strong>ArrayList</strong>替代</li>
<li><strong>BitSet类</strong>：可以高效率地存储大量开&#x2F;关信息，它的空间性能优秀，但是时间性能稍逊于数组，可以使用<strong>EnumSet</strong>替代</li>
</ul>
<h2 id="第十八章Java-I-O系统"><a href="#第十八章Java-I-O系统" class="headerlink" title="第十八章	Java I&#x2F;O系统"></a>第十八章	Java I&#x2F;O系统</h2><h3 id="18-1File类"><a href="#18-1File类" class="headerlink" title="18.1	File类"></a>18.1	File类</h3><ul>
<li><strong>目录列表器</strong>：调用<strong>list()<strong>方法获得此</strong>File</strong>对象包含的全部列表，或者编写目录过滤器生成一个受限列表</li>
<li><strong>目录的检查及创建</strong>：使用**exists()<strong>方法判断指定目录是否存在，使用</strong>mkdirs()**方法创建目录</li>
</ul>
<h3 id="18-2输入和输出"><a href="#18-2输入和输出" class="headerlink" title="18.2	输入和输出"></a>18.2	输入和输出</h3><ul>
<li><p><strong>流</strong>：代表任何有能力产出数据的数据源对象或者是有能力接收数据的接收端对象，它屏蔽了实际的<strong>I&#x2F;O</strong>设备中处理数据的细节</p>
</li>
<li><p><strong>InputStream类型</strong>：表示那些从不同数据源产生输入的类，包括字节数组，<strong>String</strong>对象，文件，管道和其他数据源</p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">功能</th>
<th align="center">构造器参数以及用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ByteArrayInputStream</strong></td>
<td align="center">允许将内存的缓冲区当做<strong>InputStream</strong>使用</td>
<td align="center">缓冲区，字节将从中取出<br>作为一种数据源，将其与<strong>FilterInputStream</strong>对象相连以提供有用的接口</td>
</tr>
<tr>
<td align="center"><strong>StringBufferInputStream</strong></td>
<td align="center">将<strong>String</strong>转换为<strong>InputStream</strong></td>
<td align="center">字符串，底层实现使用<strong>StringBuffer</strong><br/>作为一种数据源，将其与<strong>FilterInputStream</strong>对象相连以提供有用的接口</td>
</tr>
<tr>
<td align="center"><strong>FileInputStream</strong></td>
<td align="center">从文件中读取信息</td>
<td align="center">字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br/>作为一种数据源，将其与<strong>FilterInputStream</strong>对象相连以提供有用的接口</td>
</tr>
<tr>
<td align="center"><strong>PipedInputStream</strong></td>
<td align="center">产生用于写入<strong>PipedInputStream</strong>的数据，实现管道化概念</td>
<td align="center"><strong>PipedOutputStream</strong><br/>作为多线程中的数据源，将其与<strong>FilterInputStream</strong>对象相连以提供有用的接口</td>
</tr>
<tr>
<td align="center"><strong>SequenceInputStream</strong></td>
<td align="center">将两个或多个<strong>InputStream</strong>对象转换为单个<strong>InputStream</strong></td>
<td align="center">两个<strong>InputStream</strong>对象或一个容纳<strong>InputStream</strong>对象的容器<br/>作为一种数据源，将其与<strong>FilterInputStream</strong>对象相连以提供有用的接口</td>
</tr>
<tr>
<td align="center"><strong>FilterInputStream</strong></td>
<td align="center">抽象类，作为装饰器的接口</td>
<td align="center">&#x2F;</td>
</tr>
</tbody></table>
</li>
<li><p><strong>OutputStream类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">功能</th>
<th align="center">构造器参数以及用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ByteArrayOutputStream</strong></td>
<td align="center">在内存中创建缓冲区，存放要送入流的数据</td>
<td align="center">缓冲区初始尺寸<br/>指定数据的目的地，将其与<strong>FilterOutputStream</strong>对象相连以提供有用的接口</td>
</tr>
<tr>
<td align="center"><strong>FileOutputStream</strong></td>
<td align="center">将信息写入文件</td>
<td align="center">字符串，表示文件名，文件或<strong>FileDescriptor</strong>对象<br/>指定数据的目的地，将其与<strong>FilterOutputStream</strong>对象相连以提供有用的接口</td>
</tr>
<tr>
<td align="center"><strong>PipedOutputStream</strong></td>
<td align="center">作为相关<strong>PipedInputStream</strong>的输出，实现管道化概念</td>
<td align="center"><strong>PipedInputStream</strong><br/>指定用于多线程的数据目的地，将其与<strong>FilterOutputStream</strong>对象相连以提供有用的接口</td>
</tr>
<tr>
<td align="center"><strong>FilterOutputStream</strong></td>
<td align="center">抽象类，作为装饰器的接口</td>
<td align="center">&#x2F;</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="18-3添加类型和有用的接口"><a href="#18-3添加类型和有用的接口" class="headerlink" title="18.3	添加类型和有用的接口"></a>18.3	添加类型和有用的接口</h3><ul>
<li><p><strong>通过FilterInputStream从InputStream中读取数据</strong></p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">功能</th>
<th align="center">构造器参数以及用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>DataInputStream</strong></td>
<td align="center">按照可移植的方式从数据流中读取基本数据类型</td>
<td align="center"><strong>InputStream</strong><br>包含基本数据类型的全部接口</td>
</tr>
<tr>
<td align="center"><strong>BufferedInputStream</strong></td>
<td align="center">使用缓冲区，防止每次读取都进行写操作</td>
<td align="center"><strong>InputStream</strong><br/>与接口对象搭配，向进程中添加缓冲区</td>
</tr>
<tr>
<td align="center"><strong>LineNumberInputStream</strong></td>
<td align="center">跟踪输入流中的行号</td>
<td align="center"><strong>InputStream</strong><br/>与接口对象搭配使用，添加了行号</td>
</tr>
<tr>
<td align="center"><strong>PushbackInputStream</strong></td>
<td align="center">能弹出一个字节的缓冲区，可以将独到的最后一个字符回退</td>
<td align="center"><strong>InputStream</strong><br/>作为编译器的扫描器</td>
</tr>
</tbody></table>
</li>
<li><p><strong>通过FilterOutputStream向OutputStream写入</strong></p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">功能</th>
<th align="center">构造器参数以及用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>DataOutputStream</strong></td>
<td align="center">按照可移植的方式写入基本数据类型</td>
<td align="center"><strong>OutputStream</strong><br>包含基本数据类型的全部接口</td>
</tr>
<tr>
<td align="center"><strong>PrintStream</strong></td>
<td align="center">用于产生格式化输出</td>
<td align="center"><strong>OutputStream</strong><br/>对<strong>OutputStream</strong>对象进行最后的封装</td>
</tr>
<tr>
<td align="center"><strong>BufferedOutputStream</strong></td>
<td align="center">代表缓冲区，避免每次发送数据进行实际的写操作</td>
<td align="center"><strong>OutputStream</strong><br/>与接口对象搭配，向接口中添加缓冲区</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="18-4Reader和Writer"><a href="#18-4Reader和Writer" class="headerlink" title="18.4	Reader和Writer"></a>18.4	Reader和Writer</h3><ul>
<li>设计<strong>Reader</strong>和<strong>Writer</strong>继承层次结构主要是为了国际化，用于支持<strong>Unicode</strong>的<strong>I&#x2F;O</strong>操作</li>
</ul>
<h3 id="18-5自我独立的类：RandomAccessFile"><a href="#18-5自我独立的类：RandomAccessFile" class="headerlink" title="18.5	自我独立的类：RandomAccessFile"></a>18.5	自我独立的类：RandomAccessFile</h3><ul>
<li><strong>RandomAccessFile类</strong>：适用于由大小已知的记录组成的文件，它不是继承层次结构的一部分</li>
</ul>
<h3 id="18-6I-O流的典型使用方式"><a href="#18-6I-O流的典型使用方式" class="headerlink" title="18.6	I&#x2F;O流的典型使用方式"></a>18.6	I&#x2F;O流的典型使用方式</h3><ul>
<li><strong>缓冲输入文件</strong>：使用以<strong>String</strong>或<strong>File</strong>对象作为文件名的<strong>FileInputStream</strong>，将产生的引用传入<strong>BufferedReader</strong>构造器</li>
<li><strong>从内存输入</strong>：从<strong>BufferedInputFile.read()<strong>读入的</strong>String</strong>结果被用来创建<strong>StringReader</strong></li>
<li><strong>格式化的内存输入</strong>：为<strong>ByteArrayInputStream</strong>提供字节数组，产生的对象传递给<strong>DataInputStream</strong></li>
<li><strong>基本的文件输出</strong>：创建一个与指定文件连接的<strong>FileWriter</strong>，使用<strong>BufferedWriter</strong>包装以缓冲输出</li>
<li><strong>存储和恢复数据</strong>：使用<strong>DataOutputStream</strong>写入数据，用<strong>DataInputStream</strong>恢复数据</li>
<li><strong>读写随机访问文件</strong>：使用<strong>RandomAccessFile</strong>类，利用**seek()**方法在文件中移动并修改值</li>
<li><strong>管道流</strong>：在多线程中，用于任务之间的通信</li>
</ul>
<h3 id="18-7文件读写的实用工具"><a href="#18-7文件读写的实用工具" class="headerlink" title="18.7	文件读写的实用工具"></a>18.7	文件读写的实用工具</h3><ul>
<li>自定义文件读写类，以消除与这些任务相关联的重复代码</li>
</ul>
<h3 id="18-8标准I-O"><a href="#18-8标准I-O" class="headerlink" title="18.8	标准I&#x2F;O"></a>18.8	标准I&#x2F;O</h3><ul>
<li><strong>标准I&#x2F;O</strong>：程序的所有输入都可以来自<strong>标准输入</strong>，所有的输出可以发送到<strong>标准输出</strong>，以及所有的错误信息都可以发送的<strong>标准错误</strong>，标准I&#x2F;O参考了<strong>Unix</strong>操作系统的概念，使得我们可以很容易地把程序串联起来</li>
<li><strong>从标准输入中读取</strong>：使用<strong>System.in</strong>的<strong>readLine()<strong>方法读取一行输入，它是一个未经包装的</strong>PrintStream</strong>对象</li>
<li><strong>标准I&#x2F;O重定向</strong>：<strong>Java</strong>的<strong>System</strong>类提供了**setIn()<strong>，</strong>setOut()<strong>，</strong>setErr()**方法分别对输入，输出和错误流进行重定向</li>
</ul>
<h3 id="18-9进程控制"><a href="#18-9进程控制" class="headerlink" title="18.9	进程控制"></a>18.9	进程控制</h3><ul>
<li>向<strong>OSExcute.command()<strong>传递一个</strong>command</strong>字符串，与控制台上运行该程序的命令相同</li>
</ul>
<h3 id="18-10新I-O"><a href="#18-10新I-O" class="headerlink" title="18.10	新I&#x2F;O"></a>18.10	新I&#x2F;O</h3><ul>
<li><strong>新I&#x2F;O</strong>：<strong>java.nio.*<strong>包引入的新的</strong>JavaI&#x2F;O</strong>类库，使用通道和缓冲器方式，更为接近操作系统处理<strong>I&#x2F;O</strong>的方式</li>
<li><strong>转换数据</strong>：每次输入读取一个数据，然后将之转换为特定类型，对缓冲区的字节进行编码和解码</li>
<li><strong>获取基本类型</strong>：利用<strong>ByteBuffer</strong>类的**asCharBuffer()<strong>和</strong>asShortBuffer()<strong>获得缓冲器上的视图，然后使用视图的</strong>put()**方法插入基本类型数据</li>
<li><strong>视图缓冲器</strong>：通过某个特定的基本数据类型的视图查看其底层的<strong>ByteBuffer</strong></li>
<li><strong>用缓冲器操纵数据</strong>：使用<strong>ByteBuffer</strong>包装字节数组，在<strong>FileOutputStream</strong>中打开一个通道，将数据写入到通道中</li>
<li><strong>内存映射文件</strong>：允许我们创建和修改那些因为太大而不能放入内存的文件</li>
<li><strong>文件加锁</strong>：通过调用<strong>lock()<strong>获得</strong>FileLock</strong>对象</li>
</ul>
<h3 id="18-11压缩"><a href="#18-11压缩" class="headerlink" title="18.11	压缩"></a>18.11	压缩</h3><ul>
<li><p><strong>压缩类</strong></p>
<table>
<thead>
<tr>
<th align="center">压缩类</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>CheckedInputStream</strong></td>
<td align="center">为输入流产生校验和</td>
</tr>
<tr>
<td align="center"><strong>CheckedOutputStream</strong></td>
<td align="center">为输出流产生校验和</td>
</tr>
<tr>
<td align="center"><strong>DeflaterOutputStream</strong></td>
<td align="center">压缩类的基类</td>
</tr>
<tr>
<td align="center"><strong>ZipOutputStream</strong></td>
<td align="center">将数据压缩成<strong>Zip</strong>文件格式</td>
</tr>
<tr>
<td align="center"><strong>GZIPOutputStream</strong></td>
<td align="center">将数据压缩成<strong>GZIP</strong>文件格式</td>
</tr>
<tr>
<td align="center"><strong>InflaterInputStream</strong></td>
<td align="center">解压缩类的基类</td>
</tr>
<tr>
<td align="center"><strong>ZipInputStream</strong></td>
<td align="center">解压缩<strong>Zip</strong>文件格式的数据</td>
</tr>
<tr>
<td align="center"><strong>GZIPInputStream</strong></td>
<td align="center">解压缩<strong>GZIP</strong>文件格式的数据</td>
</tr>
</tbody></table>
</li>
<li><p><strong>用GZIP进行简单压缩</strong>：将输出流封装成<strong>GZIPOutputStream</strong>，再将输入流封装成<strong>GZIPINputStream</strong>，可以对单个数据流进行压缩</p>
</li>
<li><p><strong>用Zip进行多文件保存</strong>：进文件传递给<strong>ZipEntry</strong>对象，使用该对象的接口对压缩文件进行读写处理</p>
</li>
<li><p><strong>Java档案文件</strong>：<strong>JAR</strong>类似于<strong>Zip</strong>，可以合并所有需要的文件，同时含有一张描述这些文件的文件清单</p>
</li>
</ul>
<h3 id="18-12对象序列化"><a href="#18-12对象序列化" class="headerlink" title="18.12	对象序列化"></a>18.12	对象序列化</h3><ul>
<li><strong>对象序列化</strong>：将实现了<strong>Serializable</strong>接口的对象转换成一个字节序列，并能够在以后将这个字节序列恢复为原来的对象</li>
<li><strong>寻找类</strong>：必须保证<strong>Java</strong>虚拟机能够找到相关的**.class**文件</li>
<li><strong>序列化的控制</strong>：实现<strong>Externalizable</strong>而不是<strong>Serializable</strong>接口，来对序列化的过程进行控制</li>
<li><strong>transient关键字</strong>：对指定字段关闭序列化</li>
</ul>
<h3 id="18-13XML"><a href="#18-13XML" class="headerlink" title="18.13	XML"></a>18.13	XML</h3><ul>
<li><strong>XML</strong>：一种描述数据的标记语言，采用类似<strong>HTML</strong>标签的方式来表示数据的结构和属性，并支持自定义的标签和属性</li>
</ul>
<h3 id="18-14Preferences"><a href="#18-14Preferences" class="headerlink" title="18.14	Preferences"></a>18.14	Preferences</h3><ul>
<li><strong>Preferences</strong>：键-值集合，存储在一个节点层次结构</li>
</ul>
<h2 id="第十九章枚举类型"><a href="#第十九章枚举类型" class="headerlink" title="第十九章	枚举类型"></a>第十九章	枚举类型</h2><h3 id="19-1基本enum类型"><a href="#19-1基本enum类型" class="headerlink" title="19.1	基本enum类型"></a>19.1	基本enum类型</h3><ul>
<li><strong>enum关键字</strong>：将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用</li>
<li><strong>values()方法</strong>：返回枚举实例按声明顺序排列的数组，可以用于遍历枚举类型</li>
<li>创建枚举类型是，编译器会自动生成一个相关的类，继承自<strong>java.lang.Enum</strong></li>
<li><strong>将静态导入用于enum</strong>：使用<strong>import static</strong>可以将<strong>enum</strong>实例带入当前命名空间</li>
</ul>
<h3 id="19-2向enum中添加新方法"><a href="#19-2向enum中添加新方法" class="headerlink" title="19.2	向enum中添加新方法"></a>19.2	向enum中添加新方法</h3><ul>
<li>可以将枚举看成一个不能继承的普通类，可以向枚举中添加新的方法，需要在枚举实例序列中添加分号</li>
<li><strong>覆盖enum的方法</strong>：覆盖**toString()**方法，为枚举实例生成不同的字符串描述信息</li>
</ul>
<h3 id="19-3switch语句中的enum"><a href="#19-3switch语句中的enum" class="headerlink" title="19.3	switch语句中的enum"></a>19.3	switch语句中的enum</h3><ul>
<li>在<strong>switch</strong>语句中使用<strong>enum</strong>非常便利，它具备整数值的次序，并且可以通过**ordinal()**方法取得其次序</li>
</ul>
<h3 id="19-4values-的神秘之处"><a href="#19-4values-的神秘之处" class="headerlink" title="19.4	values()的神秘之处"></a>19.4	values()的神秘之处</h3><ul>
<li><strong>Enum</strong>类中并没有<strong>values()<strong>方法，它是由编译器添加的</strong>static</strong>方法</li>
</ul>
<h3 id="19-5实现，而非继承"><a href="#19-5实现，而非继承" class="headerlink" title="19.5	实现，而非继承"></a>19.5	实现，而非继承</h3><ul>
<li><strong>enum</strong>不能够继承其他类，但是可以同时实现一个或多个接口</li>
</ul>
<h3 id="19-6随机选取"><a href="#19-6随机选取" class="headerlink" title="19.6	随机选取"></a>19.6	随机选取</h3><ul>
<li>利用泛型从枚举类中随机选取值</li>
</ul>
<h3 id="19-7使用接口组织枚举"><a href="#19-7使用接口组织枚举" class="headerlink" title="19.7	使用接口组织枚举"></a>19.7	使用接口组织枚举</h3><ul>
<li>在一个接口创建枚举，实现接口以使其子类化</li>
</ul>
<h3 id="19-8使用EnumSet替代标志"><a href="#19-8使用EnumSet替代标志" class="headerlink" title="19.8	使用EnumSet替代标志"></a>19.8	使用EnumSet替代标志</h3><ul>
<li><strong>EnumSet</strong>：通过<strong>enum</strong>创建的一种替代品，具有良好的速度性能</li>
</ul>
<h3 id="19-9使用EnumMap"><a href="#19-9使用EnumMap" class="headerlink" title="19.9	使用EnumMap"></a>19.9	使用EnumMap</h3><ul>
<li><strong>EnumMap</strong>：一种特殊的<strong>Map</strong>，要求其中的键必须来自一个<strong>enum</strong></li>
</ul>
<h3 id="19-10常量相关方法"><a href="#19-10常量相关方法" class="headerlink" title="19.10	常量相关方法"></a>19.10	常量相关方法</h3><ul>
<li><strong>实现常量相关方法</strong>：定义一个或多个抽象方法，为每一个枚举实例实现该抽象方法</li>
<li><strong>使用enum的职责链</strong>：以多种不同的方式来解决一个问题，然后将它们链接在一起，当请求到来时，遍历这个链，直到找到问题的解决方案</li>
<li><strong>使用enum的状态机</strong>：一个状态机可以具有有限个特定的状态，它会根据输入进行状态的转移</li>
</ul>
<h3 id="19-11多路分发"><a href="#19-11多路分发" class="headerlink" title="19.11	多路分发"></a>19.11	多路分发</h3><ul>
<li><strong>多路分发</strong>：操作多个类型未知的对象，多个方法一同工作，产生多个结果，以解决<strong>Java</strong>绑定机制只支持单路并发的缺陷</li>
<li><strong>使用enum分发</strong>：结合<strong>switch</strong>语句，遍历参数类型</li>
<li><strong>使用常量相关的方法</strong>：为每个实例提供方法的不同实现</li>
<li><strong>使用EnumMap分发</strong>：实现两路分发</li>
<li><strong>使用二维数组</strong>：最简洁，最直接的方案，表达能力更强</li>
</ul>
<h2 id="第二十章注解"><a href="#第二十章注解" class="headerlink" title="第二十章	注解"></a>第二十章	注解</h2><h3 id="20-1基本语法"><a href="#20-1基本语法" class="headerlink" title="20.1	基本语法"></a>20.1	基本语法</h3><ul>
<li><p><strong>注解</strong>：又被称为元数据，为程序员在代码中添加信息提供了一种形式化方法，在稍后的某个时刻可以非常方便地使用这些数据</p>
</li>
<li><p><strong>注解的优点</strong></p>
<ul>
<li>完整地描述程序所需的信息</li>
<li>由编译器来测试和验证的格式，存储有关程序的额外信息</li>
<li>生成描述符文件，有助于减轻样板代码的负担</li>
<li>更加干净易读的代码以及编译期类型检查</li>
</ul>
</li>
<li><p><strong>定义注解</strong>：使用**@<strong>符号，类似于接口，也会被编译成</strong>.Class**文件</p>
</li>
<li><p><strong>元注解</strong>：专职负责注解其他的注解</p>
<table>
<thead>
<tr>
<th align="center">注解</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>@Target</strong></td>
<td align="center">表示注解可以用于什么地方，参数包括<br><strong>CONSTRUCTOR</strong>构造器<br><strong>FIELD</strong>域<br><strong>LOCAL_VARIABLE</strong>局部变量<br/><strong>METHOD</strong>方法<br/><strong>PACKAGE</strong>包<br/><strong>PARAMETER</strong>参数<br/><strong>TYPE</strong>类，接口，枚举等</td>
</tr>
<tr>
<td align="center"><strong>@Retention</strong></td>
<td align="center">表示在什么级别保存该注解信息，参数包括<br/><strong>SOURCE</strong>会被编译器丢弃<br/><strong>CLASS</strong>在<strong>class</strong>文件可用，但会被虚拟机丢弃<br/><strong>RUNTIME</strong>运行期保留，可以通过反射机制读取该注解</td>
</tr>
<tr>
<td align="center"><strong>@Document</strong></td>
<td align="center">将注解保存在<strong>Javadoc</strong>中</td>
</tr>
<tr>
<td align="center"><strong>@Inherited</strong></td>
<td align="center">允许子类继承父类的注解</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="20-2编写注解处理器"><a href="#20-2编写注解处理器" class="headerlink" title="20.2	编写注解处理器"></a>20.2	编写注解处理器</h3><ul>
<li><strong>注解处理器</strong>：运用反射机制，使用**getDeclearMethods()<strong>和</strong>getAnnotation()**提取对象中的方法和注解并进行适当的处理</li>
<li><strong>注解元素</strong>：<strong>Java</strong>注解中可以使用到的元素，包括所有的基本类型，<strong>String</strong>，<strong>Class</strong>，<strong>enum</strong>，<strong>Annotation</strong>和以上类型的数组</li>
<li><strong>默认值限制</strong>：对于非基本类型的元素，不能使用<strong>null</strong>，可以定义一些特殊值表示元素不存在</li>
<li><strong>生成外部文件</strong>：使用注解，可以将所有的信息保存在<strong>Java</strong>源文件中，不必重复地提供有关文件的相关信息</li>
<li><strong>注解不支持继承</strong>：不能使用<strong>extends</strong>继承注解，不过可以在<strong>Spring</strong>框架中使用反射机制进行注解的继承</li>
</ul>
<h3 id="20-3使用apt处理注解"><a href="#20-3使用apt处理注解" class="headerlink" title="20.3	使用apt处理注解"></a>20.3	使用apt处理注解</h3><ul>
<li><strong>注解处理工具apt</strong>：<strong>Sun</strong>公司为了帮助注解的处理过程而提供的工具，它可以在编译期间扫描和处理<strong>Java</strong>源代码中的注解，并生成新的<strong>Java</strong>代码、<strong>XML</strong>文件或其他形式的文件</li>
</ul>
<h3 id="20-4将观察者模式用于apt"><a href="#20-4将观察者模式用于apt" class="headerlink" title="20.4	将观察者模式用于apt"></a>20.4	将观察者模式用于apt</h3><ul>
<li><strong>访问者模式</strong>：一个访问者遍历某个数据类型或一个对象的集合，对其中的每一个对象执行一个操作</li>
</ul>
<h3 id="20-5基于注解的单元测试"><a href="#20-5基于注解的单元测试" class="headerlink" title="20.5	基于注解的单元测试"></a>20.5	基于注解的单元测试</h3><ul>
<li><strong>单元测试</strong>：对类中每个方法提供一个或多个测试的一种实践，用于有规律地测是一个类的各个部分是否具备正确的行为</li>
<li><strong>将@Unit用于泛型</strong>：让测试类继承自泛型类的一个特定版本</li>
<li><strong>移除测试代码</strong>：删除字节码中的**@Test**注解</li>
</ul>
<h2 id="第二十一章并发"><a href="#第二十一章并发" class="headerlink" title="第二十一章	并发"></a>第二十一章	并发</h2><h3 id="21-1并发的多面性"><a href="#21-1并发的多面性" class="headerlink" title="21.1	并发的多面性"></a>21.1	并发的多面性</h3><ul>
<li><strong>并发编程的难题</strong>：并发编程时需要解决的问题与实现并发的方式之间，没有明显的映射关系，需要有效地使用并发，以理解这些问题和特例</li>
<li><strong>更快的执行</strong>：违背直觉的是，并发编程可以提高程序在单处理器上的运行速度，因为并发编程会避免阻塞问题对程序运行速度的影响</li>
<li><strong>改进代码设计</strong>：极大地简化了相关问题的解决，<strong>Java</strong>采用协作多线程机制，在处理大量的仿真元素的问题是是一种你想的解决方案</li>
</ul>
<h3 id="21-2基本的线程机制"><a href="#21-2基本的线程机制" class="headerlink" title="21.2	基本的线程机制"></a>21.2	基本的线程机制</h3><ul>
<li><strong>线程机制</strong>：将程序分为多个分离的，独立运行的任务，这些任务中的每一个都将由执行流程来驱动，一个线程就是在进程中的一个单一的顺序控制流</li>
<li><strong>定义任务</strong>：实现<strong>Runnable</strong>接口并编写**run()**方法</li>
<li><strong>Thread类</strong>：将<strong>Runnable</strong>对象交由<strong>Thread</strong>构造器以驱动，调用<strong>start()<strong>方法为该线程执行必需的初始化操作，然后调用</strong>Runnable</strong>对象的**run()**方法，在新线程中启动该任务</li>
<li><strong>使用Executor</strong>：使用<strong>java.util.concurrent</strong>中的<strong>Executor</strong>，管理<strong>Thread</strong>对象，简化并发编程</li>
<li><strong>从任务中产生返回值</strong>：实现<strong>Callable</strong>类而不是<strong>Runnable</strong>接口</li>
<li><strong>休眠</strong>：调用**sleep()**方法，使任务中止执行给定的时间</li>
<li><strong>优先级</strong>：使用**getPriority()<strong>方法来读取现有进程的优先级，使用</strong>setPriority()**方法修改优先级</li>
<li><strong>让步</strong>：调用**yield()**方法，可以提出建议为同优先级的进程让步</li>
<li><strong>后台进程</strong>：在程序运行的时候在后台提供的一种通用服务的线程，并且不属于程序中不可或缺的一部分，使用**setDaemon()<strong>方法将方法设置为后台进程，使用</strong>isDaemon()**方法判断进程是否为后台进程</li>
<li><strong>编码的变体</strong>：直接从<strong>Thread</strong>类继承以简化并发过程</li>
<li><strong>加入一个线程</strong>：调用**join()**方法，等待一段时间知道第二个线程结束继续执行</li>
<li><strong>捕获异常</strong>：使用<strong>Execute</strong>修改产生线程的方式，在<strong>Thread</strong>对象上附着一个异常处理器</li>
</ul>
<h3 id="21-3共享受限资源"><a href="#21-3共享受限资源" class="headerlink" title="21.3	共享受限资源"></a>21.3	共享受限资源</h3><ul>
<li><strong>解决共享资源竞争</strong>：在资源被访问时，给资源加锁以避免其他线程访问，使用<strong>synchronized</strong>关键字对资源上锁</li>
<li><strong>原子性与易变性</strong>：原子操作是不能被线程调度机制中断的操作，使用<strong>volatile</strong>关键字确保应用中的可视性</li>
<li><strong>原子类</strong>：<strong>AtomicInteger</strong>，<strong>AtomicLong</strong>，<strong>AtomicReference</strong>等原子性变量类，可以在机器级别获得原子性</li>
<li><strong>临界区</strong>：访问多个线程同时访问方法内部的部分代码而不是防止访问整个方法，分离出来的代码段称为临界区</li>
<li><strong>在其他对象上同步</strong>：使用其方法正在被调用的当前对象<strong>synchronize(this)</strong></li>
<li><strong>线程本地存储</strong>：使用<strong>ThreadLocal</strong>类，为使用相同变量的每个不同的线程都创建不同的存储</li>
</ul>
<h3 id="21-4终结任务"><a href="#21-4终结任务" class="headerlink" title="21.4	终结任务"></a>21.4	终结任务</h3><ul>
<li><strong>线程状态</strong><ul>
<li><strong>新建</strong>：当线程被创建时短暂的状态，分配必需的资源并初始化</li>
<li><strong>就绪</strong>：在任意时刻，只要被调度器分配时间片，就可以运行</li>
<li><strong>阻塞</strong>：某个条件阻止线程的运行，调度器将忽略线程，不分配<strong>CPU</strong>时间，直至重新进入就绪状态</li>
<li><strong>死亡</strong>：任务已结束或者不再是可运行</li>
</ul>
</li>
<li><strong>进入阻塞状态</strong><ul>
<li>调用**sleep()**方法进入休眠状态</li>
<li>调用**wait()**使线程挂起</li>
<li>任务在等待某个输入&#x2F;输出完成</li>
<li>任务试图在某个对象上调用其同步控制方法，但对象锁不可用，因为另一个任务已经获取了该锁</li>
</ul>
</li>
<li><strong>中断</strong>：调用<strong>Thread</strong>对象的**interrupt()**方法，设置线程的中断状态</li>
<li><strong>检查中断</strong>：调用**interrupted()**来检查中断状态</li>
</ul>
<h3 id="21-5线程之间的协作"><a href="#21-5线程之间的协作" class="headerlink" title="21.5	线程之间的协作"></a>21.5	线程之间的协作</h3><ul>
<li>**wait()和notifyAll()<strong>：</strong>wait()**使得程序等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力</li>
<li><strong>notify()和notifyAll()<strong>：当程序的结构只会有一个任务实际处于</strong>wait()<strong>状态，可以使用</strong>notify()<strong>替代</strong>notifyAll()</strong></li>
<li><strong>生产者–消费者与队列</strong>：使用同步队列来解决任务协作问题，同步队列在任何时刻只允许一个任务插入或移除元素</li>
<li><strong>任务间适应管道进行输入&#x2F;输出</strong>：使用<strong>PipedWriter</strong>和<strong>PipedReader</strong>类实现管道概念</li>
</ul>
<h3 id="21-6死锁"><a href="#21-6死锁" class="headerlink" title="21.6	死锁"></a>21.6	死锁</h3><ul>
<li><strong>死锁</strong>：某个任务在等待另一个任务，而后者又等待别的任务，这样一直下去，直到这个任务上的任务又在等待第一个任务释放锁，构成了一个相互等待的连续循环，没有哪个线程能继续</li>
<li><strong>死锁产生的原因</strong><ul>
<li>互斥条件，任务使用的资源至少有一个是不能共享的</li>
<li>至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源</li>
<li>资源不能被任务抢占，任务必须把资源释放当做普通事件</li>
<li>必须有循环等待</li>
</ul>
</li>
</ul>
<h3 id="21-7新类库中的构件"><a href="#21-7新类库中的构件" class="headerlink" title="21.7	新类库中的构件"></a>21.7	新类库中的构件</h3><ul>
<li><strong>CountDownLatch</strong>：同步一个或多个任务，强制它们等待由其他任务执行的操作完成</li>
<li><strong>CyclicBarrier</strong>：多次重用的<strong>CountDownLatch</strong></li>
<li><strong>DelayQueue</strong>：用于放置实现了<strong>Delayed</strong>接口的对象，其中的对象只能在其到期时才能从队列中取走</li>
<li><strong>PriorityBlockingQueue</strong>：基础的优先级队列，具有可阻塞的读取操作</li>
<li><strong>Semaphore</strong>：允许多个任务同时访问这个资源，信号量可以被看作是在向外分发使用资源的许可证</li>
<li><strong>Exchanger</strong>：两个任务之间交换对象的栅栏</li>
</ul>
<h3 id="21-8仿真"><a href="#21-8仿真" class="headerlink" title="21.8	仿真"></a>21.8	仿真</h3><ul>
<li><strong>银行出纳员仿真</strong></li>
<li><strong>饭店仿真</strong></li>
<li><strong>分发工作</strong></li>
</ul>
<h3 id="21-9性能调优"><a href="#21-9性能调优" class="headerlink" title="21.9	性能调优"></a>21.9	性能调优</h3><ul>
<li><strong>免锁容器</strong>：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可</li>
</ul>
<h3 id="21-10活动对象"><a href="#21-10活动对象" class="headerlink" title="21.10	活动对象"></a>21.10	活动对象</h3><ul>
<li><strong>活动对象</strong>：每个对象都维护着它自己的工作器线程和消息队列，所有对这种对象的请求都将进入队列排队，任何时刻只能运行其中一个</li>
<li><strong>活动对象的特点</strong><ul>
<li>每个活动对象都可以拥有自己的工作器线程</li>
<li>每个对象都将维护对它自己的域的全部控制权</li>
<li>所有在活动对象之间的通信都将以在这些对象之间的消息形式发生</li>
<li>活动对象之间的所有消息都要排队</li>
</ul>
</li>
</ul>
<h2 id="第二十二章图形用户界面"><a href="#第二十二章图形用户界面" class="headerlink" title="第二十二章	图形用户界面"></a>第二十二章	图形用户界面</h2><h3 id="22-1applet"><a href="#22-1applet" class="headerlink" title="22.1	applet"></a>22.1	applet</h3><ul>
<li><strong>applet</strong>：一种可以在<strong>Internet</strong>上传递，并在<strong>Web</strong>浏览器中运行的程序</li>
<li><strong>applet的失败</strong>：大多数机器上并没有运行<strong>applet</strong>所必需的<strong>Java</strong>软件，为了某次特定的使用去下载和安装软件包比较麻烦</li>
</ul>
<h3 id="22-2Swing基础"><a href="#22-2Swing基础" class="headerlink" title="22.2	Swing基础"></a>22.2	Swing基础</h3><ul>
<li><strong>JFrame</strong>：大多数<strong>Swing</strong>应用被构建于此，可以在任何操作系统上创建视图应用</li>
<li><strong>一个显示框架</strong>：创建显示框架，以降低冗余代码</li>
</ul>
<h3 id="22-3创建按钮"><a href="#22-3创建按钮" class="headerlink" title="22.3	创建按钮"></a>22.3	创建按钮</h3><ul>
<li><strong>创建按钮</strong>：在标签上调用<strong>JButton</strong>构造器</li>
</ul>
<h3 id="22-4捕获事件"><a href="#22-4捕获事件" class="headerlink" title="22.4	捕获事件"></a>22.4	捕获事件</h3><ul>
<li>调用<strong>JButton</strong>的<strong>addActionListener()<strong>方法，并在类中实现</strong>ActionListener</strong>接口</li>
<li><strong>JTextField</strong>：支持用户输入文本，并放置在画布上</li>
</ul>
<h3 id="22-5文本区域"><a href="#22-5文本区域" class="headerlink" title="22.5	文本区域"></a>22.5	文本区域</h3><ul>
<li><strong>JTextArea</strong>：与<strong>JTextField</strong>类似，其中的**append()**方法可以用来添加文本</li>
</ul>
<h3 id="22-6控制布局"><a href="#22-6控制布局" class="headerlink" title="22.6	控制布局"></a>22.6	控制布局</h3><ul>
<li><p><strong>BorderLayout</strong>：默认的布局模式，接收**add()**方法加入组件</p>
<table>
<thead>
<tr>
<th align="center">常量值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>BorderLayout.NORTH</strong></td>
<td align="center"><strong>顶端</strong></td>
</tr>
<tr>
<td align="center"><strong>BorderLayout.SOUTH</strong></td>
<td align="center"><strong>底端</strong></td>
</tr>
<tr>
<td align="center"><strong>BorderLayout.EAST</strong></td>
<td align="center"><strong>右端</strong></td>
</tr>
<tr>
<td align="center"><strong>BorderLayout.WEST</strong></td>
<td align="center"><strong>左端</strong></td>
</tr>
<tr>
<td align="center"><strong>BorderLayout.CENTER</strong></td>
<td align="center"><strong>中央</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>FlowLayout</strong>：从左到右流动到窗体，直到占满上方的空间，然后下移一行继续流动</p>
</li>
<li><p><strong>GridLayout</strong>：允许构建放置组件的表格，按照从左到右，从上到下的顺序加入组件</p>
</li>
<li><p><strong>GridBagLayout</strong>：精确判断视窗区域如何布局，以及视窗大小变化的时候如何放置组件</p>
</li>
</ul>
<h3 id="22-7Swing事件模型"><a href="#22-7Swing事件模型" class="headerlink" title="22.7	Swing事件模型"></a>22.7	Swing事件模型</h3><ul>
<li><strong>事件与监听器的模型</strong>：所有的<strong>Swing</strong>组件都具有**addXXXListener()<strong>和</strong>removeXXXListener()**方法，用于添加和移除相应类型的监听器</li>
</ul>
<h3 id="22-8Swing组件一览"><a href="#22-8Swing组件一览" class="headerlink" title="22.8	Swing组件一览"></a>22.8	Swing组件一览</h3><ul>
<li><strong>按钮</strong>：从<strong>AbstractButton</strong>类继承各种类型的按钮类</li>
<li><strong>图标</strong>：在<strong>JLable</strong>或者从<strong>AbstractButtton</strong>类继承的组件中使用<strong>Icon</strong></li>
<li><strong>工具提示</strong>：用来创建用户接口的类，绝大多数继承自<strong>JComponent</strong>类</li>
<li><strong>文本域</strong>：<strong>JTextField</strong>组件</li>
<li><strong>边框</strong>：<strong>JComponent</strong>的**setBorder()**方法，可以为任何可视组件设置各种边框</li>
<li><strong>复选框</strong>：接收标签作为参数创建<strong>JCheckBox</strong></li>
<li><strong>单选按钮</strong>：设置一组关联的<strong>JRadioButton</strong></li>
<li><strong>组合框</strong>：使用<strong>JComboBox</strong>组合框</li>
<li><strong>列表框</strong>：使用<strong>JList</strong>在屏幕上生成列表</li>
<li><strong>页签面板</strong>：<strong>JTabbedPane</strong>允许创建页签式对话框</li>
<li><strong>消息框</strong>：<strong>JOptionPane</strong>组件，可以提供包括消息对话框和确认对话框在内的很多选择</li>
<li><strong>菜单</strong>：每个持有菜单地子类，包括<strong>JApplet</strong>，<strong>JFrame</strong>，<strong>JDialog</strong>以及它们的子类，都具有**setJMenuBar()**方法用于接收参数对象</li>
<li><strong>弹出式菜单</strong>：创建一个继承自<strong>MouseAdapter</strong>的内部类</li>
<li><strong>绘图</strong>：从<strong>JPanel</strong>继承，并覆盖<strong>paintComponent</strong>方法</li>
<li><strong>对话框</strong>：继承<strong>JDialog</strong>，添加事件监听器来处理事件</li>
<li><strong>文件对话框</strong>：使用<strong>JFileChooser</strong></li>
<li><strong>Swing组件上的HTML</strong>：任何<strong>Swing</strong>组件都可以接受<strong>HTML</strong>文本，并且重新格式化文本</li>
</ul>
<h3 id="22-9JNLP与Java-Web-Start"><a href="#22-9JNLP与Java-Web-Start" class="headerlink" title="22.9	JNLP与Java Web Start"></a>22.9	JNLP与Java Web Start</h3><ul>
<li><strong>JNLP</strong>：<strong>Java</strong>网络发布协议，在保持<strong>applet</strong>的优点的前提下，解决了<strong>applet</strong>只能在浏览器上运行等问题</li>
<li><strong>Java Web Start</strong>：由<strong>Sun</strong>免费提供的<strong>JNLP</strong>的官方参考实现</li>
</ul>
<h3 id="22-10Swing与并发"><a href="#22-10Swing与并发" class="headerlink" title="22.10	Swing与并发"></a>22.10	Swing与并发</h3><ul>
<li><strong>长期运行的任务</strong>：在单独的线程中执行长期运行的任务</li>
</ul>
<h3 id="22-11可视化编程与JavaBean"><a href="#22-11可视化编程与JavaBean" class="headerlink" title="22.11	可视化编程与JavaBean"></a>22.11	可视化编程与JavaBean</h3><ul>
<li><strong>可视化编程</strong>：<strong>IDE</strong>构建工具通过反射机制来动态地向组件查询，以找出组件具有的属性和支持的事件</li>
<li><strong>JavaBean</strong>：一种符合特定规范的Java类，常用于图形用户界面编程、数据持久化和<strong>Web</strong>应用程序开发中<ul>
<li>对于一个名称为<strong>xxx</strong>的属性，通常具有两个方法：<strong>getXxx()<strong>和</strong>setXxx()</strong></li>
<li>对于布尔型属性，可以使用上述方法，也可以将<strong>get</strong>替换为<strong>is</strong></li>
<li><strong>Bean</strong>的普通方法不必遵循以上的命名规则，不过它们必须是<strong>public</strong>的</li>
<li>对于事件，要是用<strong>Swing</strong>中处理监听器的方式</li>
</ul>
</li>
<li><strong>JavaBean与同步</strong>：尽可能让<strong>Bean</strong>中的所有公共方法都是<strong>synchronize</strong>的；当一个多路事件触发了一组对该事件感兴趣的监听器时，必须假定在遍历列表进行通知的同时监听器可能被移除或添加</li>
</ul>
<h2 id="第二十三章Java8新特性"><a href="#第二十三章Java8新特性" class="headerlink" title="第二十三章	Java8新特性"></a>第二十三章	Java8新特性</h2><h3 id="第一节为什么要关心Java8"><a href="#第一节为什么要关心Java8" class="headerlink" title="第一节	为什么要关心Java8"></a>第一节	为什么要关心Java8</h3><h4 id="1-1Java怎么还在变"><a href="#1-1Java怎么还在变" class="headerlink" title="1.1	Java怎么还在变"></a>1.1	Java怎么还在变</h4><h4 id="1-2Java中的函数"><a href="#1-2Java中的函数" class="headerlink" title="1.2	Java中的函数"></a>1.2	Java中的函数</h4><h4 id="1-3流"><a href="#1-3流" class="headerlink" title="1.3	流"></a>1.3	流</h4><h4 id="1-4默认方法"><a href="#1-4默认方法" class="headerlink" title="1.4	默认方法"></a>1.4	默认方法</h4><h4 id="1-5来自函数式编程的其他好思想"><a href="#1-5来自函数式编程的其他好思想" class="headerlink" title="1.5	来自函数式编程的其他好思想"></a>1.5	来自函数式编程的其他好思想</h4><h3 id="第二节通过行为参数化传递代码"><a href="#第二节通过行为参数化传递代码" class="headerlink" title="第二节	通过行为参数化传递代码"></a>第二节	通过行为参数化传递代码</h3><h4 id="2-1应对不断变化的需求"><a href="#2-1应对不断变化的需求" class="headerlink" title="2.1	应对不断变化的需求"></a>2.1	应对不断变化的需求</h4><h4 id="2-2行为参数化"><a href="#2-2行为参数化" class="headerlink" title="2.2	行为参数化"></a>2.2	行为参数化</h4><h4 id="2-3对付啰嗦"><a href="#2-3对付啰嗦" class="headerlink" title="2.3	对付啰嗦"></a>2.3	对付啰嗦</h4><h4 id="2-4真实的例子"><a href="#2-4真实的例子" class="headerlink" title="2.4	真实的例子"></a>2.4	真实的例子</h4><h3 id="第三节Lambda表达式"><a href="#第三节Lambda表达式" class="headerlink" title="第三节	Lambda表达式"></a>第三节	Lambda表达式</h3><h4 id="3-1Lambda管中窥豹"><a href="#3-1Lambda管中窥豹" class="headerlink" title="3.1	Lambda管中窥豹"></a>3.1	Lambda管中窥豹</h4><h4 id="3-2在哪里以及如何使用Lambda"><a href="#3-2在哪里以及如何使用Lambda" class="headerlink" title="3.2	在哪里以及如何使用Lambda"></a>3.2	在哪里以及如何使用Lambda</h4><h4 id="3-3把Lambda付诸实践：环绕执行模式"><a href="#3-3把Lambda付诸实践：环绕执行模式" class="headerlink" title="3.3	把Lambda付诸实践：环绕执行模式"></a>3.3	把Lambda付诸实践：环绕执行模式</h4><h4 id="3-4使用函数式接口"><a href="#3-4使用函数式接口" class="headerlink" title="3.4	使用函数式接口"></a>3.4	使用函数式接口</h4><h4 id="3-5类型检查，类型推断以及限制"><a href="#3-5类型检查，类型推断以及限制" class="headerlink" title="3.5	类型检查，类型推断以及限制"></a>3.5	类型检查，类型推断以及限制</h4><h4 id="3-6方法引用"><a href="#3-6方法引用" class="headerlink" title="3.6	方法引用"></a>3.6	方法引用</h4><h4 id="3-7Lambda的方法引用实践"><a href="#3-7Lambda的方法引用实践" class="headerlink" title="3.7	Lambda的方法引用实践"></a>3.7	Lambda的方法引用实践</h4><h4 id="3-8复合Lambda表达式的有用方法"><a href="#3-8复合Lambda表达式的有用方法" class="headerlink" title="3.8	复合Lambda表达式的有用方法"></a>3.8	复合Lambda表达式的有用方法</h4><h4 id="3-9数学中的类似思想"><a href="#3-9数学中的类似思想" class="headerlink" title="3.9	数学中的类似思想"></a>3.9	数学中的类似思想</h4><h3 id="第四节引入流"><a href="#第四节引入流" class="headerlink" title="第四节	引入流"></a>第四节	引入流</h3><h4 id="4-1流是什么"><a href="#4-1流是什么" class="headerlink" title="4.1	流是什么"></a>4.1	流是什么</h4><h4 id="4-2流简介"><a href="#4-2流简介" class="headerlink" title="4.2	流简介"></a>4.2	流简介</h4><h4 id="4-3流与集合"><a href="#4-3流与集合" class="headerlink" title="4.3	流与集合"></a>4.3	流与集合</h4><h4 id="4-4流操作"><a href="#4-4流操作" class="headerlink" title="4.4	流操作"></a>4.4	流操作</h4><h3 id="第五节使用流"><a href="#第五节使用流" class="headerlink" title="第五节	使用流"></a>第五节	使用流</h3><h4 id="5-1筛选和切片"><a href="#5-1筛选和切片" class="headerlink" title="5.1	筛选和切片"></a>5.1	筛选和切片</h4><h4 id="5-2映射"><a href="#5-2映射" class="headerlink" title="5.2	映射"></a>5.2	映射</h4><h4 id="5-3查找和匹配"><a href="#5-3查找和匹配" class="headerlink" title="5.3	查找和匹配"></a>5.3	查找和匹配</h4><h4 id="5-4归约"><a href="#5-4归约" class="headerlink" title="5.4	归约"></a>5.4	归约</h4><h4 id="5-5付诸实践"><a href="#5-5付诸实践" class="headerlink" title="5.5	付诸实践"></a>5.5	付诸实践</h4><h4 id="5-6数值流"><a href="#5-6数值流" class="headerlink" title="5.6	数值流"></a>5.6	数值流</h4><h4 id="5-7构建流"><a href="#5-7构建流" class="headerlink" title="5.7	构建流"></a>5.7	构建流</h4><h3 id="第六节用流收集数据"><a href="#第六节用流收集数据" class="headerlink" title="第六节	用流收集数据"></a>第六节	用流收集数据</h3><h4 id="6-1收集器简介"><a href="#6-1收集器简介" class="headerlink" title="6.1	收集器简介"></a>6.1	收集器简介</h4><h4 id="6-2归约和汇总"><a href="#6-2归约和汇总" class="headerlink" title="6.2	归约和汇总"></a>6.2	归约和汇总</h4><h4 id="6-3分组"><a href="#6-3分组" class="headerlink" title="6.3	分组"></a>6.3	分组</h4><h4 id="6-4分区"><a href="#6-4分区" class="headerlink" title="6.4	分区"></a>6.4	分区</h4><h4 id="6-5收集器接口"><a href="#6-5收集器接口" class="headerlink" title="6.5	收集器接口"></a>6.5	收集器接口</h4><h4 id="6-6开发你自己的收集器以获得更好的性能"><a href="#6-6开发你自己的收集器以获得更好的性能" class="headerlink" title="6.6	开发你自己的收集器以获得更好的性能"></a>6.6	开发你自己的收集器以获得更好的性能</h4><h3 id="第七节并行数据处理与性能"><a href="#第七节并行数据处理与性能" class="headerlink" title="第七节	并行数据处理与性能"></a>第七节	并行数据处理与性能</h3><h4 id="7-1并行流"><a href="#7-1并行流" class="headerlink" title="7.1	并行流"></a>7.1	并行流</h4><h4 id="7-2分支-合并框架"><a href="#7-2分支-合并框架" class="headerlink" title="7.2	分支&#x2F;合并框架"></a>7.2	分支&#x2F;合并框架</h4><h4 id="7-3Spliterator"><a href="#7-3Spliterator" class="headerlink" title="7.3	Spliterator"></a>7.3	Spliterator</h4><h3 id="第八节重构，测试和调试"><a href="#第八节重构，测试和调试" class="headerlink" title="第八节	重构，测试和调试"></a>第八节	重构，测试和调试</h3><h4 id="8-1为改善可读性和灵活性重构代码"><a href="#8-1为改善可读性和灵活性重构代码" class="headerlink" title="8.1	为改善可读性和灵活性重构代码"></a>8.1	为改善可读性和灵活性重构代码</h4><h4 id="8-2使用Lambda重构面向对象的设计模式"><a href="#8-2使用Lambda重构面向对象的设计模式" class="headerlink" title="8.2	使用Lambda重构面向对象的设计模式"></a>8.2	使用Lambda重构面向对象的设计模式</h4><h4 id="8-3测试Lambda表达式"><a href="#8-3测试Lambda表达式" class="headerlink" title="8.3	测试Lambda表达式"></a>8.3	测试Lambda表达式</h4><h4 id="8-4调试"><a href="#8-4调试" class="headerlink" title="8.4	调试"></a>8.4	调试</h4><h3 id="第九节默认方法"><a href="#第九节默认方法" class="headerlink" title="第九节	默认方法"></a>第九节	默认方法</h3><h4 id="9-1不断演进的API"><a href="#9-1不断演进的API" class="headerlink" title="9.1	不断演进的API"></a>9.1	不断演进的API</h4><h4 id="9-2概述默认方法"><a href="#9-2概述默认方法" class="headerlink" title="9.2	概述默认方法"></a>9.2	概述默认方法</h4><h4 id="9-3默认方法的使用模式"><a href="#9-3默认方法的使用模式" class="headerlink" title="9.3	默认方法的使用模式"></a>9.3	默认方法的使用模式</h4><h4 id="9-4解决冲突的规则"><a href="#9-4解决冲突的规则" class="headerlink" title="9.4	解决冲突的规则"></a>9.4	解决冲突的规则</h4><h3 id="第十节用optional替代null"><a href="#第十节用optional替代null" class="headerlink" title="第十节	用optional替代null"></a>第十节	用optional替代null</h3><h4 id="10-1如何为缺失的值建模"><a href="#10-1如何为缺失的值建模" class="headerlink" title="10.1	如何为缺失的值建模"></a>10.1	如何为缺失的值建模</h4><h4 id="10-2Optional类入门"><a href="#10-2Optional类入门" class="headerlink" title="10.2	Optional类入门"></a>10.2	Optional类入门</h4><h4 id="10-3应用Optional的几种模式"><a href="#10-3应用Optional的几种模式" class="headerlink" title="10.3	应用Optional的几种模式"></a>10.3	应用Optional的几种模式</h4><h4 id="10-4使用Optional的实战示例"><a href="#10-4使用Optional的实战示例" class="headerlink" title="10.4	使用Optional的实战示例"></a>10.4	使用Optional的实战示例</h4><h3 id="第十一节CompletableFuture：组合式异步编程"><a href="#第十一节CompletableFuture：组合式异步编程" class="headerlink" title="第十一节	CompletableFuture：组合式异步编程"></a>第十一节	CompletableFuture：组合式异步编程</h3><h4 id="11-1Future接口"><a href="#11-1Future接口" class="headerlink" title="11.1	Future接口"></a>11.1	Future接口</h4><h4 id="11-2实现异步API"><a href="#11-2实现异步API" class="headerlink" title="11.2	实现异步API"></a>11.2	实现异步API</h4><h4 id="11-3让你的代码免受阻塞之苦"><a href="#11-3让你的代码免受阻塞之苦" class="headerlink" title="11.3	让你的代码免受阻塞之苦"></a>11.3	让你的代码免受阻塞之苦</h4><h4 id="11-4对多个异步任务进行流水线操作"><a href="#11-4对多个异步任务进行流水线操作" class="headerlink" title="11.4	对多个异步任务进行流水线操作"></a>11.4	对多个异步任务进行流水线操作</h4><h4 id="11-5响应CompletableFuture的completion事件"><a href="#11-5响应CompletableFuture的completion事件" class="headerlink" title="11.5	响应CompletableFuture的completion事件"></a>11.5	响应CompletableFuture的completion事件</h4><h3 id="第十二节新的日期和时间API"><a href="#第十二节新的日期和时间API" class="headerlink" title="第十二节	新的日期和时间API"></a>第十二节	新的日期和时间API</h3><h4 id="12-1LocalDate，LocalTime，Instant，Duration以及Period"><a href="#12-1LocalDate，LocalTime，Instant，Duration以及Period" class="headerlink" title="12.1	LocalDate，LocalTime，Instant，Duration以及Period"></a>12.1	LocalDate，LocalTime，Instant，Duration以及Period</h4><h4 id="12-2操纵，解析和格式化日期"><a href="#12-2操纵，解析和格式化日期" class="headerlink" title="12.2	操纵，解析和格式化日期"></a>12.2	操纵，解析和格式化日期</h4><h4 id="12-3处理不同的时区和历法"><a href="#12-3处理不同的时区和历法" class="headerlink" title="12.3	处理不同的时区和历法"></a>12.3	处理不同的时区和历法</h4><h3 id="第十三节函数式的思考"><a href="#第十三节函数式的思考" class="headerlink" title="第十三节	函数式的思考"></a>第十三节	函数式的思考</h3><h4 id="13-1实现和维护系统"><a href="#13-1实现和维护系统" class="headerlink" title="13.1	实现和维护系统"></a>13.1	实现和维护系统</h4><h4 id="13-2什么是函数式编程"><a href="#13-2什么是函数式编程" class="headerlink" title="13.2	什么是函数式编程"></a>13.2	什么是函数式编程</h4><h4 id="13-3递归和迭代"><a href="#13-3递归和迭代" class="headerlink" title="13.3	递归和迭代"></a>13.3	递归和迭代</h4><h3 id="第十四节函数式编程的技巧"><a href="#第十四节函数式编程的技巧" class="headerlink" title="第十四节	函数式编程的技巧"></a>第十四节	函数式编程的技巧</h3><h4 id="14-1无处不在的函数"><a href="#14-1无处不在的函数" class="headerlink" title="14.1	无处不在的函数"></a>14.1	无处不在的函数</h4><h4 id="14-2持久化数据结构"><a href="#14-2持久化数据结构" class="headerlink" title="14.2	持久化数据结构"></a>14.2	持久化数据结构</h4><h4 id="14-3Stream的延迟计算"><a href="#14-3Stream的延迟计算" class="headerlink" title="14.3	Stream的延迟计算"></a>14.3	Stream的延迟计算</h4><h4 id="14-4模式匹配"><a href="#14-4模式匹配" class="headerlink" title="14.4	模式匹配"></a>14.4	模式匹配</h4><h4 id="14-5杂项"><a href="#14-5杂项" class="headerlink" title="14.5	杂项"></a>14.5	杂项</h4><h3 id="第十五节面向对象和函数式编程的混合：Java8和Scala的比较"><a href="#第十五节面向对象和函数式编程的混合：Java8和Scala的比较" class="headerlink" title="第十五节	面向对象和函数式编程的混合：Java8和Scala的比较"></a>第十五节	面向对象和函数式编程的混合：Java8和Scala的比较</h3><h4 id="15-1Scala简介"><a href="#15-1Scala简介" class="headerlink" title="15.1	Scala简介"></a>15.1	Scala简介</h4><h4 id="15-2函数"><a href="#15-2函数" class="headerlink" title="15.2	函数"></a>15.2	函数</h4><h4 id="15-3类和trait"><a href="#15-3类和trait" class="headerlink" title="15.3	类和trait"></a>15.3	类和trait</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">huzzsea</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/">http://example.com/2024/01/28/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">huzzsea</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/28/Docker/" title="Docker"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/28/Java-SE%E5%9F%BA%E7%A1%80/" title="Java SE基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java SE基础</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">huzzsea</div><div class="author-info__description">心有所向，无问东西</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章	对象导论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E6%8A%BD%E8%B1%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1	抽象过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">1.2	每个对象都有一个接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">1.3	每个对象都提供服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">1.4	被隐藏的具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E5%A4%8D%E7%94%A8%E5%85%B7%E4%BD%93%E4%BD%93%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text">1.5	复用具体体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6%E7%BB%A7%E6%89%BF"><span class="toc-number">1.6.</span> <span class="toc-text">1.6	继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7%E4%BC%B4%E9%9A%8F%E5%A4%9A%E6%80%81%E7%9A%84%E5%8F%AF%E4%BA%92%E6%8D%A2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.</span> <span class="toc-text">1.7	伴随多态的可互换对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8%E5%8D%95%E6%A0%B9%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text">1.8	单根继承结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9%E5%AE%B9%E5%99%A8"><span class="toc-number">1.9.</span> <span class="toc-text">1.9	容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="toc-number">1.10.</span> <span class="toc-text">1.10	对象的创建和生命期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">1.11.</span> <span class="toc-text">1.11	异常处理：处理错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.12.</span> <span class="toc-text">1.12	并发编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13Java%E4%B8%8EInternet"><span class="toc-number">1.13.</span> <span class="toc-text">1.13	Java与Internet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Web%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.13.1.</span> <span class="toc-text">Web是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-number">1.13.2.</span> <span class="toc-text">客户端编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-number">1.13.3.</span> <span class="toc-text">服务器端编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">第二章	一切都是对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E7%94%A8%E5%BC%95%E7%94%A8%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">2.1	用引用操纵对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%BF%85%E9%A1%BB%E7%94%B1%E4%BD%A0%E5%88%9B%E5%BB%BA%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">2.2	必须由你创建所有对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%88%B0%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">存储到什么地方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E4%BE%8B%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">特例：基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.3.</span> <span class="toc-text">Java中的数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E6%B0%B8%E8%BF%9C%E4%B8%8D%E9%9C%80%E8%A6%81%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.</span> <span class="toc-text">2.3	永远不需要销毁对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">2.4	创建新的数据类型，类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.5.</span> <span class="toc-text">2.5	方法，参数与返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.6.</span> <span class="toc-text">2.6	构建一个Java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.7.</span> <span class="toc-text">2.7	你的第一个Java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8%E6%B3%A8%E9%87%8A%E4%B8%8E%E5%B5%8C%E5%85%A5%E6%96%87%E6%A1%A3"><span class="toc-number">2.8.</span> <span class="toc-text">2.8	注释与嵌入文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="toc-number">2.9.</span> <span class="toc-text">2.9	编程风格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">第三章	操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.</span> <span class="toc-text">3.1	更简单的打印语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E4%BD%BF%E7%94%A8Java%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text">3.2	使用Java操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.3.</span> <span class="toc-text">3.3	优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E8%B5%8B%E5%80%BC"><span class="toc-number">3.4.</span> <span class="toc-text">3.4	赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.5.</span> <span class="toc-text">3.5	算术操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E8%87%AA%E5%8A%A8%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F"><span class="toc-number">3.6.</span> <span class="toc-text">3.6	自动递增和递减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.7.</span> <span class="toc-text">3.7	关系操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.8.</span> <span class="toc-text">3.8	逻辑操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9%E7%9B%B4%E6%8E%A5%E5%B8%B8%E9%87%8F"><span class="toc-number">3.9.</span> <span class="toc-text">3.9	直接常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.10.</span> <span class="toc-text">3.10	按位操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.11.</span> <span class="toc-text">3.11	移位操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6if-else"><span class="toc-number">3.12.</span> <span class="toc-text">3.12	三元操作符if-else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%92%8C"><span class="toc-number">3.13.</span> <span class="toc-text">3.13	字符串操作符+和+&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%97%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">3.14.</span> <span class="toc-text">3.14	使用操作符时常犯的错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-15%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.15.</span> <span class="toc-text">3.15	类型转换操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-16Java%E6%B2%A1%E6%9C%89sizeof"><span class="toc-number">3.16.</span> <span class="toc-text">3.16	Java没有sizeof</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">第四章	控制执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1true%E5%92%8Cfalse"><span class="toc-number">4.1.</span> <span class="toc-text">4.1	true和false</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2if-else"><span class="toc-number">4.2.</span> <span class="toc-text">4.2	if-else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E8%BF%AD%E4%BB%A3"><span class="toc-number">4.3.</span> <span class="toc-text">4.3	迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4Foreach%E8%AF%AD%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">4.4	Foreach语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5return"><span class="toc-number">4.5.</span> <span class="toc-text">4.5	return</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6break%E5%92%8Ccontinue"><span class="toc-number">4.6.</span> <span class="toc-text">4.6	break和continue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7%E8%87%AD%E5%90%8D%E6%98%AD%E8%91%97%E7%9A%84goto"><span class="toc-number">4.7.</span> <span class="toc-text">4.7	臭名昭著的goto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8switch"><span class="toc-number">4.8.</span> <span class="toc-text">4.8	switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">第五章	初始化与清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E7%A1%AE%E4%BF%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">5.1	用构造器确保初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.</span> <span class="toc-text">5.2	方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">5.3	默认构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.4.</span> <span class="toc-text">5.4	this关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5%E6%B8%85%E7%90%86%EF%BC%9A%E7%BB%88%E7%BB%93%E5%A4%84%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">5.5.</span> <span class="toc-text">5.5	清理：终结处理和垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.6.</span> <span class="toc-text">5.6	成员初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.7.</span> <span class="toc-text">5.7	构造器初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.8.</span> <span class="toc-text">5.8	数组初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.9.</span> <span class="toc-text">5.9	枚举类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">第六章	访问权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E5%8C%85%EF%BC%9A%E5%BA%93%E5%8D%95%E5%85%83"><span class="toc-number">6.1.</span> <span class="toc-text">6.1	包：库单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E8%AF%8D"><span class="toc-number">6.2.</span> <span class="toc-text">6.2	Java访问权限修饰词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.</span> <span class="toc-text">6.3	接口和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">6.4.</span> <span class="toc-text">6.4	类的访问权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%A4%8D%E7%94%A8%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">第七章	复用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E7%BB%84%E5%90%88%E8%AF%AD%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">7.1	组合语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">7.2	继承语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E4%BB%A3%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">7.3	代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4%E7%BB%93%E5%90%88%E5%AE%9E%E7%94%A8%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">7.4.</span> <span class="toc-text">7.4	结合实用组合和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5%E5%9C%A8%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E4%B9%8B%E9%97%B4%E9%80%89%E6%8B%A9"><span class="toc-number">7.5.</span> <span class="toc-text">7.5	在组合与继承之间选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6protected%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.6.</span> <span class="toc-text">7.6	protected关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">7.7.</span> <span class="toc-text">7.7	向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.8.</span> <span class="toc-text">7.8	final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.9.</span> <span class="toc-text">7.9	初始化及类的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%A4%9A%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">第八章	多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E5%86%8D%E8%AE%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">8.1.</span> <span class="toc-text">8.1	再论向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E8%BD%AC%E6%9C%BA"><span class="toc-number">8.2.</span> <span class="toc-text">8.2	转机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">8.3.</span> <span class="toc-text">8.3	构造器和多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.4.</span> <span class="toc-text">8.4	协变返回类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5%E7%94%A8%E7%BB%A7%E6%89%BF%E8%BF%9B%E8%A1%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.5.</span> <span class="toc-text">8.5	用继承进行设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">第九章	接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">9.1	抽象类和抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.2.</span> <span class="toc-text">9.2	接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%80%A6"><span class="toc-number">9.3.</span> <span class="toc-text">9.3	完全解耦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">9.4.</span> <span class="toc-text">9.4	Java中的多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E6%8B%93%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.5.</span> <span class="toc-text">9.5	通过继承来拓展接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6%E9%80%82%E9%85%8D%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.6.</span> <span class="toc-text">9.6	适配接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%9F%9F"><span class="toc-number">9.7.</span> <span class="toc-text">9.7	接口中的域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.8.</span> <span class="toc-text">9.8	嵌套接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-9%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82"><span class="toc-number">9.9.</span> <span class="toc-text">9.9	接口与工厂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">第十章	内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E5%88%9B%E5%BB%BA%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.1.</span> <span class="toc-text">10.1	创建内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E9%93%BE%E6%8E%A5%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB"><span class="toc-number">10.2.</span> <span class="toc-text">10.2	链接到外部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%E4%BD%BF%E7%94%A8-this%E4%B8%8E-new"><span class="toc-number">10.3.</span> <span class="toc-text">10.3	使用.this与.new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">10.4.</span> <span class="toc-text">10.4	内部类与向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.5.</span> <span class="toc-text">10.5	在方法和作用域内的内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.6.</span> <span class="toc-text">10.6	匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">10.7.</span> <span class="toc-text">10.7	嵌套类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.8.</span> <span class="toc-text">10.8	为什么需要内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">10.9.</span> <span class="toc-text">10.9	内部类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-10%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%A6%86%E7%9B%96%E5%90%97"><span class="toc-number">10.10.</span> <span class="toc-text">10.10	内部类可以被覆盖吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-11%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.11.</span> <span class="toc-text">10.11	局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-12%E5%86%85%E9%83%A8%E7%B1%BB%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">10.12.</span> <span class="toc-text">10.12	内部类标识符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.</span> <span class="toc-text">第十一章	持有对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">11.1	泛型和类型安全的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">11.2.</span> <span class="toc-text">11.2	基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">11.3.</span> <span class="toc-text">11.3	添加一组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4%E5%AE%B9%E5%99%A8%E7%9A%84%E6%89%93%E5%8D%B0"><span class="toc-number">11.4.</span> <span class="toc-text">11.4	容器的打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5List"><span class="toc-number">11.5.</span> <span class="toc-text">11.5	List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">11.6.</span> <span class="toc-text">11.6	迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7LinkedList"><span class="toc-number">11.7.</span> <span class="toc-text">11.7	LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-8Stack"><span class="toc-number">11.8.</span> <span class="toc-text">11.8	Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-9Set"><span class="toc-number">11.9.</span> <span class="toc-text">11.9	Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-10Map"><span class="toc-number">11.10.</span> <span class="toc-text">11.10	Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-11Queue"><span class="toc-number">11.11.</span> <span class="toc-text">11.11	Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-12Collection%E5%92%8CIterator"><span class="toc-number">11.12.</span> <span class="toc-text">11.12	Collection和Iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-13Foreach%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">11.13.</span> <span class="toc-text">11.13	Foreach与迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">12.</span> <span class="toc-text">第十二章	通过异常处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1%E6%A6%82%E5%BF%B5"><span class="toc-number">12.1.</span> <span class="toc-text">12.1	概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2%E5%9F%BA%E6%9C%AC%E5%BC%82%E5%B8%B8"><span class="toc-number">12.2.</span> <span class="toc-text">12.2	基本异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">12.3.</span> <span class="toc-text">12.3	捕获异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">12.4.</span> <span class="toc-text">12.4	创建自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="toc-number">12.5.</span> <span class="toc-text">12.5	异常说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8"><span class="toc-number">12.6.</span> <span class="toc-text">12.6	捕获所有异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7Java%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-number">12.7.</span> <span class="toc-text">12.7	Java标准异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-8%E4%BD%BF%E7%94%A8finally%E8%BF%9B%E8%A1%8C%E6%B8%85%E7%90%86"><span class="toc-number">12.8.</span> <span class="toc-text">12.8	使用finally进行清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-9%E5%BC%82%E5%B8%B8%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">12.9.</span> <span class="toc-text">12.9	异常的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-10%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">12.10.</span> <span class="toc-text">12.10	构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-11%E5%BC%82%E5%B8%B8%E5%8C%B9%E9%85%8D"><span class="toc-number">12.11.</span> <span class="toc-text">12.11	异常匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-12%E5%85%B6%E4%BB%96%E5%8F%AF%E9%80%89%E6%96%B9%E5%BC%8F"><span class="toc-number">12.12.</span> <span class="toc-text">12.12	其他可选方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-13%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97"><span class="toc-number">12.13.</span> <span class="toc-text">12.13	异常使用指南</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">13.</span> <span class="toc-text">第十三章	字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1%E4%B8%8D%E5%8F%AF%E5%8F%98String"><span class="toc-number">13.1.</span> <span class="toc-text">13.1	不可变String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2%E9%87%8D%E8%BD%BD%E2%80%9C-%E2%80%9D%E4%B8%8EStringBuilder"><span class="toc-number">13.2.</span> <span class="toc-text">13.2	重载“+”与StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3%E6%97%A0%E6%84%8F%E8%AF%86%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">13.3.</span> <span class="toc-text">13.3	无意识的递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4String%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">13.4.</span> <span class="toc-text">13.4	String上的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">13.5.</span> <span class="toc-text">13.5	格式化输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">13.6.</span> <span class="toc-text">13.6	正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7%E6%89%AB%E6%8F%8F%E8%BE%93%E5%85%A5"><span class="toc-number">13.7.</span> <span class="toc-text">13.7	扫描输入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">14.</span> <span class="toc-text">第十四章	类型信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81RTTI"><span class="toc-number">14.1.</span> <span class="toc-text">14.1	为什么需要RTTI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2Class%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.2.</span> <span class="toc-text">14.2	Class对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%89%8D%E5%85%88%E5%81%9A%E6%A3%80%E6%9F%A5"><span class="toc-number">14.3.</span> <span class="toc-text">14.3	类型转换前先做检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82"><span class="toc-number">14.4.</span> <span class="toc-text">14.4	注册工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5instanceof%E4%B8%8EClass%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-number">14.5.</span> <span class="toc-text">14.5	instanceof与Class的等价性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6%E5%8F%8D%E5%B0%84%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-number">14.6.</span> <span class="toc-text">14.6	反射：运行时的类信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">14.7.</span> <span class="toc-text">14.7	动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-8%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.8.</span> <span class="toc-text">14.8	空对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-9%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">14.9.</span> <span class="toc-text">14.9	接口与类型信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%E6%B3%9B%E5%9E%8B"><span class="toc-number">15.</span> <span class="toc-text">第十五章	泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1%E4%B8%8EC-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">15.1.</span> <span class="toc-text">15.1	与C++的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B"><span class="toc-number">15.2.</span> <span class="toc-text">15.2	简单泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.3.</span> <span class="toc-text">15.3	泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">15.4.</span> <span class="toc-text">15.4	泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">15.5.</span> <span class="toc-text">15.5	匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-6%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">15.6.</span> <span class="toc-text">15.6	构建复杂模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-7%E6%93%A6%E5%87%BA%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84"><span class="toc-number">15.7.</span> <span class="toc-text">15.7	擦出的神秘之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-8%E6%93%A6%E9%99%A4%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-number">15.8.</span> <span class="toc-text">15.8	擦除的补偿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-9%E8%BE%B9%E7%95%8C"><span class="toc-number">15.9.</span> <span class="toc-text">15.9	边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-10%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">15.10.</span> <span class="toc-text">15.10	通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-11%E9%97%AE%E9%A2%98"><span class="toc-number">15.11.</span> <span class="toc-text">15.11	问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-12%E8%87%AA%E9%99%90%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.12.</span> <span class="toc-text">15.12	自限定的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-13%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-number">15.13.</span> <span class="toc-text">15.13	动态类型安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-14%E5%BC%82%E5%B8%B8"><span class="toc-number">15.14.</span> <span class="toc-text">15.14	异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-15%E6%B7%B7%E5%9E%8B"><span class="toc-number">15.15.</span> <span class="toc-text">15.15	混型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-16%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">15.16.</span> <span class="toc-text">15.16	潜在类型机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-17%E5%AF%B9%E7%BC%BA%E4%B9%8F%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-number">15.17.</span> <span class="toc-text">15.17	对缺乏潜在类型机制的补偿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-18%E5%B0%86%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BD%9C%E7%AD%96%E7%95%A5"><span class="toc-number">15.18.</span> <span class="toc-text">15.18	将函数对象用作策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-19%E6%80%BB%E7%BB%93%EF%BC%9A%E8%BD%AC%E5%9E%8B%E7%9C%9F%E7%9A%84%E5%A6%82%E6%AD%A4%E4%B9%8B%E7%B3%9F%E5%90%97%EF%BC%9F"><span class="toc-number">15.19.</span> <span class="toc-text">15.19	总结：转型真的如此之糟吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%E6%95%B0%E7%BB%84"><span class="toc-number">16.</span> <span class="toc-text">第十六章	数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BB%80%E4%B9%88%E7%89%B9%E6%AE%8A"><span class="toc-number">16.1.</span> <span class="toc-text">16.1	数组为什么特殊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2%E6%95%B0%E7%BB%84%E6%98%AF%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.2.</span> <span class="toc-text">16.2	数组是第一级对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">16.3.</span> <span class="toc-text">16.3	返回一个数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">16.4.</span> <span class="toc-text">16.4	多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5%E6%95%B0%E7%BB%84%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.5.</span> <span class="toc-text">16.5	数组与泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-number">16.6.</span> <span class="toc-text">16.6	创建测试数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7Arrays%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">16.7.</span> <span class="toc-text">16.7	Arrays实用功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6"><span class="toc-number">17.</span> <span class="toc-text">第十七章	容器深入研究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB%E6%B3%95"><span class="toc-number">17.1.</span> <span class="toc-text">17.1	完整的容器分类法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2%E5%A1%AB%E5%85%85%E5%AE%B9%E5%99%A8"><span class="toc-number">17.2.</span> <span class="toc-text">17.2	填充容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3Collection%E7%9A%84%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-number">17.3.</span> <span class="toc-text">17.3	Collection的功能方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4%E5%8F%AF%E9%80%89%E6%93%8D%E4%BD%9C"><span class="toc-number">17.4.</span> <span class="toc-text">17.4	可选操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-5List%E7%9A%84%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-number">17.5.</span> <span class="toc-text">17.5	List的功能方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-6Set%E5%92%8C%E5%AD%98%E5%82%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">17.6.</span> <span class="toc-text">17.6	Set和存储顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-7%E9%98%9F%E5%88%97"><span class="toc-number">17.7.</span> <span class="toc-text">17.7	队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-8%E7%90%86%E8%A7%A3Map"><span class="toc-number">17.8.</span> <span class="toc-text">17.8	理解Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-9%E6%95%A3%E5%88%97%E4%B8%8E%E6%95%A3%E5%88%97%E7%A0%81"><span class="toc-number">17.9.</span> <span class="toc-text">17.9	散列与散列码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-10%E9%80%89%E6%8B%A9%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">17.10.</span> <span class="toc-text">17.10	选择接口的不同实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-11%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">17.11.</span> <span class="toc-text">17.11	实用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-12%E6%8C%81%E6%9C%89%E5%BC%95%E7%94%A8"><span class="toc-number">17.12.</span> <span class="toc-text">17.12	持有引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-13Java-1-0-1-1%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">17.13.</span> <span class="toc-text">17.13	Java 1.0&#x2F;1.1的容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0Java-I-O%E7%B3%BB%E7%BB%9F"><span class="toc-number">18.</span> <span class="toc-text">第十八章	Java I&#x2F;O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1File%E7%B1%BB"><span class="toc-number">18.1.</span> <span class="toc-text">18.1	File类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">18.2.</span> <span class="toc-text">18.2	输入和输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9C%89%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">18.3.</span> <span class="toc-text">18.3	添加类型和有用的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4Reader%E5%92%8CWriter"><span class="toc-number">18.4.</span> <span class="toc-text">18.4	Reader和Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5%E8%87%AA%E6%88%91%E7%8B%AC%E7%AB%8B%E7%9A%84%E7%B1%BB%EF%BC%9ARandomAccessFile"><span class="toc-number">18.5.</span> <span class="toc-text">18.5	自我独立的类：RandomAccessFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6I-O%E6%B5%81%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">18.6.</span> <span class="toc-text">18.6	I&#x2F;O流的典型使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">18.7.</span> <span class="toc-text">18.7	文件读写的实用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-8%E6%A0%87%E5%87%86I-O"><span class="toc-number">18.8.</span> <span class="toc-text">18.8	标准I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-9%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">18.9.</span> <span class="toc-text">18.9	进程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-10%E6%96%B0I-O"><span class="toc-number">18.10.</span> <span class="toc-text">18.10	新I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-11%E5%8E%8B%E7%BC%A9"><span class="toc-number">18.11.</span> <span class="toc-text">18.11	压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-12%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">18.12.</span> <span class="toc-text">18.12	对象序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-13XML"><span class="toc-number">18.13.</span> <span class="toc-text">18.13	XML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-14Preferences"><span class="toc-number">18.14.</span> <span class="toc-text">18.14	Preferences</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">第十九章	枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1%E5%9F%BA%E6%9C%ACenum%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.1.</span> <span class="toc-text">19.1	基本enum类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2%E5%90%91enum%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%96%B9%E6%B3%95"><span class="toc-number">19.2.</span> <span class="toc-text">19.2	向enum中添加新方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3switch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84enum"><span class="toc-number">19.3.</span> <span class="toc-text">19.3	switch语句中的enum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-4values-%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84"><span class="toc-number">19.4.</span> <span class="toc-text">19.4	values()的神秘之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-5%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%80%8C%E9%9D%9E%E7%BB%A7%E6%89%BF"><span class="toc-number">19.5.</span> <span class="toc-text">19.5	实现，而非继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-6%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96"><span class="toc-number">19.6.</span> <span class="toc-text">19.6	随机选取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-7%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%BB%84%E7%BB%87%E6%9E%9A%E4%B8%BE"><span class="toc-number">19.7.</span> <span class="toc-text">19.7	使用接口组织枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-8%E4%BD%BF%E7%94%A8EnumSet%E6%9B%BF%E4%BB%A3%E6%A0%87%E5%BF%97"><span class="toc-number">19.8.</span> <span class="toc-text">19.8	使用EnumSet替代标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-9%E4%BD%BF%E7%94%A8EnumMap"><span class="toc-number">19.9.</span> <span class="toc-text">19.9	使用EnumMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-10%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">19.10.</span> <span class="toc-text">19.10	常量相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-11%E5%A4%9A%E8%B7%AF%E5%88%86%E5%8F%91"><span class="toc-number">19.11.</span> <span class="toc-text">19.11	多路分发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%E6%B3%A8%E8%A7%A3"><span class="toc-number">20.</span> <span class="toc-text">第二十章	注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-1%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">20.1.</span> <span class="toc-text">20.1	基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2%E7%BC%96%E5%86%99%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">20.2.</span> <span class="toc-text">20.2	编写注解处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3%E4%BD%BF%E7%94%A8apt%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="toc-number">20.3.</span> <span class="toc-text">20.3	使用apt处理注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-4%E5%B0%86%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%94%A8%E4%BA%8Eapt"><span class="toc-number">20.4.</span> <span class="toc-text">20.4	将观察者模式用于apt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">20.5.</span> <span class="toc-text">20.5	基于注解的单元测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0%E5%B9%B6%E5%8F%91"><span class="toc-number">21.</span> <span class="toc-text">第二十一章	并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-1%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%9A%E9%9D%A2%E6%80%A7"><span class="toc-number">21.1.</span> <span class="toc-text">21.1	并发的多面性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-2%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">21.2.</span> <span class="toc-text">21.2	基本的线程机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-3%E5%85%B1%E4%BA%AB%E5%8F%97%E9%99%90%E8%B5%84%E6%BA%90"><span class="toc-number">21.3.</span> <span class="toc-text">21.3	共享受限资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-4%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1"><span class="toc-number">21.4.</span> <span class="toc-text">21.4	终结任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-5%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-number">21.5.</span> <span class="toc-text">21.5	线程之间的协作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-6%E6%AD%BB%E9%94%81"><span class="toc-number">21.6.</span> <span class="toc-text">21.6	死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-7%E6%96%B0%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84%E6%9E%84%E4%BB%B6"><span class="toc-number">21.7.</span> <span class="toc-text">21.7	新类库中的构件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-8%E4%BB%BF%E7%9C%9F"><span class="toc-number">21.8.</span> <span class="toc-text">21.8	仿真</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-9%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">21.9.</span> <span class="toc-text">21.9	性能调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-10%E6%B4%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">21.10.</span> <span class="toc-text">21.10	活动对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-number">22.</span> <span class="toc-text">第二十二章	图形用户界面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-1applet"><span class="toc-number">22.1.</span> <span class="toc-text">22.1	applet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-2Swing%E5%9F%BA%E7%A1%80"><span class="toc-number">22.2.</span> <span class="toc-text">22.2	Swing基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3%E5%88%9B%E5%BB%BA%E6%8C%89%E9%92%AE"><span class="toc-number">22.3.</span> <span class="toc-text">22.3	创建按钮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-4%E6%8D%95%E8%8E%B7%E4%BA%8B%E4%BB%B6"><span class="toc-number">22.4.</span> <span class="toc-text">22.4	捕获事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5%E6%96%87%E6%9C%AC%E5%8C%BA%E5%9F%9F"><span class="toc-number">22.5.</span> <span class="toc-text">22.5	文本区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-6%E6%8E%A7%E5%88%B6%E5%B8%83%E5%B1%80"><span class="toc-number">22.6.</span> <span class="toc-text">22.6	控制布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-7Swing%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">22.7.</span> <span class="toc-text">22.7	Swing事件模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-8Swing%E7%BB%84%E4%BB%B6%E4%B8%80%E8%A7%88"><span class="toc-number">22.8.</span> <span class="toc-text">22.8	Swing组件一览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-9JNLP%E4%B8%8EJava-Web-Start"><span class="toc-number">22.9.</span> <span class="toc-text">22.9	JNLP与Java Web Start</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-10Swing%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">22.10.</span> <span class="toc-text">22.10	Swing与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-11%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E7%A8%8B%E4%B8%8EJavaBean"><span class="toc-number">22.11.</span> <span class="toc-text">22.11	可视化编程与JavaBean</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0Java8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">23.</span> <span class="toc-text">第二十三章	Java8新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%85%B3%E5%BF%83Java8"><span class="toc-number">23.1.</span> <span class="toc-text">第一节	为什么要关心Java8</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1Java%E6%80%8E%E4%B9%88%E8%BF%98%E5%9C%A8%E5%8F%98"><span class="toc-number">23.1.1.</span> <span class="toc-text">1.1	Java怎么还在变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2Java%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">23.1.2.</span> <span class="toc-text">1.2	Java中的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E6%B5%81"><span class="toc-number">23.1.3.</span> <span class="toc-text">1.3	流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">23.1.4.</span> <span class="toc-text">1.4	默认方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5%E6%9D%A5%E8%87%AA%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%B6%E4%BB%96%E5%A5%BD%E6%80%9D%E6%83%B3"><span class="toc-number">23.1.5.</span> <span class="toc-text">1.5	来自函数式编程的其他好思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82%E9%80%9A%E8%BF%87%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81"><span class="toc-number">23.2.</span> <span class="toc-text">第二节	通过行为参数化传递代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E5%BA%94%E5%AF%B9%E4%B8%8D%E6%96%AD%E5%8F%98%E5%8C%96%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-number">23.2.1.</span> <span class="toc-text">2.1	应对不断变化的需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">23.2.2.</span> <span class="toc-text">2.2	行为参数化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E5%AF%B9%E4%BB%98%E5%95%B0%E5%97%A6"><span class="toc-number">23.2.3.</span> <span class="toc-text">2.3	对付啰嗦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E7%9C%9F%E5%AE%9E%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">23.2.4.</span> <span class="toc-text">2.4	真实的例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">23.3.</span> <span class="toc-text">第三节	Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1Lambda%E7%AE%A1%E4%B8%AD%E7%AA%A5%E8%B1%B9"><span class="toc-number">23.3.1.</span> <span class="toc-text">3.1	Lambda管中窥豹</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E5%9C%A8%E5%93%AA%E9%87%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Lambda"><span class="toc-number">23.3.2.</span> <span class="toc-text">3.2	在哪里以及如何使用Lambda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E6%8A%8ALambda%E4%BB%98%E8%AF%B8%E5%AE%9E%E8%B7%B5%EF%BC%9A%E7%8E%AF%E7%BB%95%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.3.3.</span> <span class="toc-text">3.3	把Lambda付诸实践：环绕执行模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">23.3.4.</span> <span class="toc-text">3.4	使用函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%EF%BC%8C%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%BB%A5%E5%8F%8A%E9%99%90%E5%88%B6"><span class="toc-number">23.3.5.</span> <span class="toc-text">3.5	类型检查，类型推断以及限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">23.3.6.</span> <span class="toc-text">3.6	方法引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7Lambda%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%AE%9E%E8%B7%B5"><span class="toc-number">23.3.7.</span> <span class="toc-text">3.7	Lambda的方法引用实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8%E5%A4%8D%E5%90%88Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9C%89%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">23.3.8.</span> <span class="toc-text">3.8	复合Lambda表达式的有用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9%E6%95%B0%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BC%BC%E6%80%9D%E6%83%B3"><span class="toc-number">23.3.9.</span> <span class="toc-text">3.9	数学中的类似思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82%E5%BC%95%E5%85%A5%E6%B5%81"><span class="toc-number">23.4.</span> <span class="toc-text">第四节	引入流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">23.4.1.</span> <span class="toc-text">4.1	流是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E6%B5%81%E7%AE%80%E4%BB%8B"><span class="toc-number">23.4.2.</span> <span class="toc-text">4.2	流简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3%E6%B5%81%E4%B8%8E%E9%9B%86%E5%90%88"><span class="toc-number">23.4.3.</span> <span class="toc-text">4.3	流与集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4%E6%B5%81%E6%93%8D%E4%BD%9C"><span class="toc-number">23.4.4.</span> <span class="toc-text">4.4	流操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82%E4%BD%BF%E7%94%A8%E6%B5%81"><span class="toc-number">23.5.</span> <span class="toc-text">第五节	使用流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1%E7%AD%9B%E9%80%89%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">23.5.1.</span> <span class="toc-text">5.1	筛选和切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2%E6%98%A0%E5%B0%84"><span class="toc-number">23.5.2.</span> <span class="toc-text">5.2	映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3%E6%9F%A5%E6%89%BE%E5%92%8C%E5%8C%B9%E9%85%8D"><span class="toc-number">23.5.3.</span> <span class="toc-text">5.3	查找和匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4%E5%BD%92%E7%BA%A6"><span class="toc-number">23.5.4.</span> <span class="toc-text">5.4	归约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5%E4%BB%98%E8%AF%B8%E5%AE%9E%E8%B7%B5"><span class="toc-number">23.5.5.</span> <span class="toc-text">5.5	付诸实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6%E6%95%B0%E5%80%BC%E6%B5%81"><span class="toc-number">23.5.6.</span> <span class="toc-text">5.6	数值流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7%E6%9E%84%E5%BB%BA%E6%B5%81"><span class="toc-number">23.5.7.</span> <span class="toc-text">5.7	构建流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%8A%82%E7%94%A8%E6%B5%81%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE"><span class="toc-number">23.6.</span> <span class="toc-text">第六节	用流收集数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">23.6.1.</span> <span class="toc-text">6.1	收集器简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E5%BD%92%E7%BA%A6%E5%92%8C%E6%B1%87%E6%80%BB"><span class="toc-number">23.6.2.</span> <span class="toc-text">6.2	归约和汇总</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E5%88%86%E7%BB%84"><span class="toc-number">23.6.3.</span> <span class="toc-text">6.3	分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4%E5%88%86%E5%8C%BA"><span class="toc-number">23.6.4.</span> <span class="toc-text">6.4	分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5%E6%94%B6%E9%9B%86%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">23.6.5.</span> <span class="toc-text">6.5	收集器接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6%E5%BC%80%E5%8F%91%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">23.6.6.</span> <span class="toc-text">6.6	开发你自己的收集器以获得更好的性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E8%8A%82%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="toc-number">23.7.</span> <span class="toc-text">第七节	并行数据处理与性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="toc-number">23.7.1.</span> <span class="toc-text">7.1	并行流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2%E5%88%86%E6%94%AF-%E5%90%88%E5%B9%B6%E6%A1%86%E6%9E%B6"><span class="toc-number">23.7.2.</span> <span class="toc-text">7.2	分支&#x2F;合并框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3Spliterator"><span class="toc-number">23.7.3.</span> <span class="toc-text">7.3	Spliterator</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E8%8A%82%E9%87%8D%E6%9E%84%EF%BC%8C%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95"><span class="toc-number">23.8.</span> <span class="toc-text">第八节	重构，测试和调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1%E4%B8%BA%E6%94%B9%E5%96%84%E5%8F%AF%E8%AF%BB%E6%80%A7%E5%92%8C%E7%81%B5%E6%B4%BB%E6%80%A7%E9%87%8D%E6%9E%84%E4%BB%A3%E7%A0%81"><span class="toc-number">23.8.1.</span> <span class="toc-text">8.1	为改善可读性和灵活性重构代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2%E4%BD%BF%E7%94%A8Lambda%E9%87%8D%E6%9E%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.8.2.</span> <span class="toc-text">8.2	使用Lambda重构面向对象的设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3%E6%B5%8B%E8%AF%95Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">23.8.3.</span> <span class="toc-text">8.3	测试Lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4%E8%B0%83%E8%AF%95"><span class="toc-number">23.8.4.</span> <span class="toc-text">8.4	调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E8%8A%82%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">23.9.</span> <span class="toc-text">第九节	默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1%E4%B8%8D%E6%96%AD%E6%BC%94%E8%BF%9B%E7%9A%84API"><span class="toc-number">23.9.1.</span> <span class="toc-text">9.1	不断演进的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2%E6%A6%82%E8%BF%B0%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">23.9.2.</span> <span class="toc-text">9.2	概述默认方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.9.3.</span> <span class="toc-text">9.3	默认方法的使用模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">23.9.4.</span> <span class="toc-text">9.4	解决冲突的规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E8%8A%82%E7%94%A8optional%E6%9B%BF%E4%BB%A3null"><span class="toc-number">23.10.</span> <span class="toc-text">第十节	用optional替代null</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1%E5%A6%82%E4%BD%95%E4%B8%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%80%BC%E5%BB%BA%E6%A8%A1"><span class="toc-number">23.10.1.</span> <span class="toc-text">10.1	如何为缺失的值建模</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2Optional%E7%B1%BB%E5%85%A5%E9%97%A8"><span class="toc-number">23.10.2.</span> <span class="toc-text">10.2	Optional类入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3%E5%BA%94%E7%94%A8Optional%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.10.3.</span> <span class="toc-text">10.3	应用Optional的几种模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4%E4%BD%BF%E7%94%A8Optional%E7%9A%84%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">23.10.4.</span> <span class="toc-text">10.4	使用Optional的实战示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E8%8A%82CompletableFuture%EF%BC%9A%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">23.11.</span> <span class="toc-text">第十一节	CompletableFuture：组合式异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1Future%E6%8E%A5%E5%8F%A3"><span class="toc-number">23.11.1.</span> <span class="toc-text">11.1	Future接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5API"><span class="toc-number">23.11.2.</span> <span class="toc-text">11.2	实现异步API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E5%85%8D%E5%8F%97%E9%98%BB%E5%A1%9E%E4%B9%8B%E8%8B%A6"><span class="toc-number">23.11.3.</span> <span class="toc-text">11.3	让你的代码免受阻塞之苦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4%E5%AF%B9%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%BF%9B%E8%A1%8C%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%93%8D%E4%BD%9C"><span class="toc-number">23.11.4.</span> <span class="toc-text">11.4	对多个异步任务进行流水线操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5%E5%93%8D%E5%BA%94CompletableFuture%E7%9A%84completion%E4%BA%8B%E4%BB%B6"><span class="toc-number">23.11.5.</span> <span class="toc-text">11.5	响应CompletableFuture的completion事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%8A%82%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4API"><span class="toc-number">23.12.</span> <span class="toc-text">第十二节	新的日期和时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1LocalDate%EF%BC%8CLocalTime%EF%BC%8CInstant%EF%BC%8CDuration%E4%BB%A5%E5%8F%8APeriod"><span class="toc-number">23.12.1.</span> <span class="toc-text">12.1	LocalDate，LocalTime，Instant，Duration以及Period</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2%E6%93%8D%E7%BA%B5%EF%BC%8C%E8%A7%A3%E6%9E%90%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="toc-number">23.12.2.</span> <span class="toc-text">12.2	操纵，解析和格式化日期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%97%B6%E5%8C%BA%E5%92%8C%E5%8E%86%E6%B3%95"><span class="toc-number">23.12.3.</span> <span class="toc-text">12.3	处理不同的时区和历法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E8%8A%82%E5%87%BD%E6%95%B0%E5%BC%8F%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">23.13.</span> <span class="toc-text">第十三节	函数式的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BB%B4%E6%8A%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">23.13.1.</span> <span class="toc-text">13.1	实现和维护系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">23.13.2.</span> <span class="toc-text">13.2	什么是函数式编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3"><span class="toc-number">23.13.3.</span> <span class="toc-text">13.3	递归和迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%8A%82%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">23.14.</span> <span class="toc-text">第十四节	函数式编程的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">23.14.1.</span> <span class="toc-text">14.1	无处不在的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">23.14.2.</span> <span class="toc-text">14.2	持久化数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3Stream%E7%9A%84%E5%BB%B6%E8%BF%9F%E8%AE%A1%E7%AE%97"><span class="toc-number">23.14.3.</span> <span class="toc-text">14.3	Stream的延迟计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">23.14.4.</span> <span class="toc-text">14.4	模式匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5%E6%9D%82%E9%A1%B9"><span class="toc-number">23.14.5.</span> <span class="toc-text">14.5	杂项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E8%8A%82%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%B7%B7%E5%90%88%EF%BC%9AJava8%E5%92%8CScala%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">23.15.</span> <span class="toc-text">第十五节	面向对象和函数式编程的混合：Java8和Scala的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1Scala%E7%AE%80%E4%BB%8B"><span class="toc-number">23.15.1.</span> <span class="toc-text">15.1	Scala简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2%E5%87%BD%E6%95%B0"><span class="toc-number">23.15.2.</span> <span class="toc-text">15.2	函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3%E7%B1%BB%E5%92%8Ctrait"><span class="toc-number">23.15.3.</span> <span class="toc-text">15.3	类和trait</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/26/RabbitMQ/" title="RabbitMQ">RabbitMQ</a><time datetime="2024-07-26T15:32:51.000Z" title="发表于 2024-07-26 23:32:51">2024-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/24/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2024-07-23T16:29:47.000Z" title="发表于 2024-07-24 00:29:47">2024-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/11/Shell/" title="Shell">Shell</a><time datetime="2024-06-11T13:27:53.000Z" title="发表于 2024-06-11 21:27:53">2024-06-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/06/Redis/" title="Redis">Redis</a><time datetime="2024-06-05T16:31:51.000Z" title="发表于 2024-06-06 00:31:51">2024-06-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/29/Python/" title="Python">Python</a><time datetime="2024-01-28T16:00:11.000Z" title="发表于 2024-01-29 00:00:11">2024-01-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By huzzsea</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>